---
title: "function_documentation"
output: html_document
editor_options: 
  chunk_output_type: console
---
<!-- Work in progress --  All file is commented -->
<!-- ```{r development, include=FALSE} -->
<!-- library(testthat) -->
<!-- ``` -->

<!-- ```{r development-load} -->
<!-- # Load already included functions if relevant -->
<!-- pkgload::load_all(export_all = FALSE) -->
<!-- ``` -->

<!-- # ADD functions -->

<!-- ## add_percentage_missing -->

<!-- ```{r function-add_percentage_missing} -->
<!-- #' Adds the percentage of missing values per row -->
<!-- #' -->
<!-- #' @param dataset A dataset to add the percentage of missing values -->
<!-- #' @param column_name string variable with the name of the new column to be created, default is percentage_missing -->
<!-- #' @param kobo_survey Kobo survey sheet. -->
<!-- #' @param type_to_include Types (from KOBO) to be included in the columns default are -->
<!-- #' integer, date, text, select_one and select_multiple. -->
<!-- #' -->
<!-- #' @return a dataset with the one additional column with the percentage of missing value -->
<!-- #' @export -->
<!-- #' -->
<!-- #' @seealso [cleaningtools::check_percentage_missing()] -->

<!-- add_percentage_missing <- -->
<!--   function(dataset, -->
<!--            column_name = "percentage_missing", -->
<!--            kobo_survey = NULL, -->
<!--            type_to_include = c("integer", "date", "text", "select_one", "select_multiple")) { -->
<!--     if (!is.null(kobo_survey)) { -->
<!--       if (!all(c("type", "name") %in% names(kobo_survey))) { -->
<!--         stop("Cannot identify type and/or name columns in kobo") -->
<!--       } -->

<!--       type_only <- kobo_survey$type |> -->
<!--         stringr::word(1) |> -->
<!--         unique() -->

<!--       not_found <- type_to_include[!type_to_include %in% type_only] -->
<!--       if (length(not_found) > 0) { -->
<!--         msg <- not_found |> -->
<!--           glue::glue_collapse(sep = ", ") %>% -->
<!--           glue::glue("Following type: ", ., " cannot be found in the kobo tool") -->
<!--         stop(msg) -->
<!--       } -->
<!--     } -->

<!--     if (column_name %in% names(dataset)) { -->
<!--       msg <- glue::glue("There is already a column called ", column_name) -->
<!--       stop(msg) -->
<!--     } -->

<!--     if (is.null(kobo_survey)) { -->
<!--       dataset <- dataset %>% -->
<!--         dplyr::mutate(!!rlang::sym(column_name) := rowSums(dplyr::across(.cols = dplyr::everything(), .fns = is.na)) / ncol(.)) -->
<!--       return(dataset) -->
<!--     } else { -->
<!--       lookup_value <- type_to_include %>% stringr::str_c(collapse = "|") -->

<!--       col_to_count <- kobo_survey %>% -->
<!--         dplyr::filter(stringr::str_detect(type, lookup_value)) %>% -->
<!--         dplyr::filter(name %in% names(dataset)) %>% -->
<!--         dplyr::pull(name) -->

<!--       dataset <- dataset %>% -->
<!--         dplyr::mutate(!!rlang::sym(column_name) := rowSums(dplyr::across( -->
<!--           .cols = dplyr::all_of(col_to_count), -->
<!--           .fns = is.na -->
<!--         )) / length(col_to_count)) -->
<!--       return(dataset) -->
<!--     } -->
<!--   } -->

<!-- ``` -->

<!-- ```{r example-add_percentage_missing} -->
<!-- ## Define data  -->
<!-- data_test <- data.frame( -->
<!--   uuid = c(1:3), -->
<!--   col_1 = c(1:3), -->
<!--   col_2 = c(NA, NA, "expenditures"), -->
<!--   col_3 = c("with need", NA, "with need"), -->
<!--   col_4 = c("food health school", NA, "food"), -->
<!--   col_4.food = c(1, NA, 1), -->
<!--   col_4.health = c(1, NA, 0), -->
<!--   col_4.school = c(1, NA, 0)) -->

<!-- # Define questionnaire -->
<!-- kobo_survey <- data.frame( -->
<!--   type = c( "uuid", -->
<!--             "integer", -->
<!--             "select_one choice2", -->
<!--             "select_one choice3", -->
<!--             "select_multiple choice4"  ), -->
<!--   name = c("uuid", "col_1", "col_2", "col_3", "col_4")) -->

<!-- data_test |> -->
<!--   add_percentage_missing( kobo_survey = kobo_survey, -->
<!--                           type_to_include = c("integer", "select_one", -->
<!--                                               "select_multiple")) |> -->
<!--   knitr::kable() -->

<!-- data_test |> -->
<!--   add_percentage_missing() |> -->
<!--   knitr::kable() -->
<!-- ``` -->

<!-- ```{r tests-add_percentage_missing} -->
<!-- test_that("add_percentage_missing works", { -->
<!--   expect_true(inherits(add_percentage_missing, "function"))  -->
<!-- }) -->
<!-- ``` -->



<!-- ## add_duration -->

<!-- ```{r function-add_duration} -->
<!-- #' add_duration -->
<!-- #'  -->
<!-- #' Creates a duration variable using the start and end time of the survey -->
<!-- #' -->
<!-- #' @param dataset dataset to add the duration -->
<!-- #' @param duration_column the name of the duration variable that will be created. -->
<!-- #' @param uuid_column uuid column in the dataset. Default is uuid. -->
<!-- #' @param start_column start time of the survey, in KOBO format (e.g "2021-07-14T14:02:24.955+03:00") -->
<!-- #' @param end_column end time of the survey, in KOBO format (e.g "2021-07-14T14:03:28.955+03:00") -->
<!-- #' @return the clean dataset with 6 new columns: duration, start_date, start_time, end_date, end_time, days_diff -->
<!-- #' @export -->
<!-- add_duration <- function(dataset, duration_column = "duration", -->
<!--                          uuid_column = "uuid", start_column = "start", end_column = "end") { -->
<!--   # make the dataset a dataframe -->
<!--   dataset <- as.data.frame(dataset) -->

<!--   # if start_column column doesn exist, error. same for end_column [test 1] -->
<!--   if (!(start_column %in% names(dataset))) { -->
<!--     stop("data needs to have a column start for this function work") -->
<!--   } -->
<!--   if (!(end_column %in% names(dataset))) { -->
<!--     stop("data needs to have a column end for this function work") -->
<!--   } -->

<!--   # if the duration_column column already exist [test 2] -->
<!--   if (duration_column %in% names(dataset)) { -->
<!--     stop("There is already a variable called duration_column in your dataset, please input another duration_column") -->
<!--   } -->

<!--   # the function only runs if start_column and end_column are in the KOBO format "date T hour" -->
<!--   if ((all(grepl("T", dataset[[start_column]]) | is.na(dataset[[start_column]])) & all(grepl("T", dataset[[end_column]]) | is.na(dataset[[end_column]]))) | -->
<!--     all(grepl("^\\d{4}/\\d{2}/\\d{2}\\s\\d{2}:\\d{2}:\\d{2}$", dataset[[start_column]])) & all(grepl("^\\d{4}/\\d{2}/\\d{2}\\s\\d{2}:\\d{2}:\\d{2}$", dataset[[end_column]]))) { -->
<!--     # split the columns start_column and end_column -->
<!--     if (all(grepl("^\\d{4}/\\d{2}/\\d{2}\\s\\d{2}:\\d{2}:\\d{2}$", dataset[[start_column]])) & all(grepl("^\\d{4}/\\d{2}/\\d{2}\\s\\d{2}:\\d{2}:\\d{2}$", dataset[[end_column]]))) { -->
<!--       dataset <- dataset %>% -->
<!--         tidyr::separate(!!rlang::sym(start_column), c("start_date", "start_time"), " ", remove = F) %>% -->
<!--         tidyr::separate(!!rlang::sym(end_column), c("end_date", "end_time"), " ", remove = F) -->
<!--     } else { -->
<!--       dataset <- dataset %>% -->
<!--         tidyr::separate(!!rlang::sym(start_column), c("start_date", "start_time"), "T", remove = F) %>% -->
<!--         tidyr::separate(!!rlang::sym(end_column), c("end_date", "end_time"), "T", remove = F) -->
<!--     } -->

<!--     # test 3: warning if there is not a start_column and end_column for each survey -->
<!--     if (sum(is.na(dataset[[start_column]])) > 0 | sum(is.na(dataset[[end_column]])) > 0) { -->
<!--       warning("There are some observations for which either start or end is missing. The duration will not be computed for these") -->
<!--     } -->

<!--     # compute days diff and create days count -->
<!--     dataset$days_diff <- difftime(as.POSIXct(dataset$end_date), -->
<!--       as.POSIXct(dataset$start_date), -->
<!--       units = "days" -->
<!--     ) -->
<!--     # round the time -->
<!--     dataset$start_time <- round(as.difftime(dataset$start_time, -->
<!--       units = "mins" -->
<!--     ), 2) -->
<!--     dataset$end_time <- round(as.difftime(dataset$end_time, -->
<!--       units = "mins" -->
<!--     ), 2) -->
<!--     # compute the duration -->
<!--     dataset[[duration_column]] <- as.numeric(dataset$end_time - -->
<!--       dataset$start_time) + -->
<!--       (as.numeric(dataset$days_diff) * 24 * 60) -->

<!--     # return in list format -->
<!--     return(dataset) -->
<!--   } else { -->
<!--     stop("The dates are not in the correct format, the duration cannot be computed") -->
<!--   } -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-add_duration} -->

<!-- test_data <- data.frame( -->
<!--   start = c( -->
<!--     "2021/07/13 11:25:49", "2021/07/13 12:36:16", -->
<!--     "2021/07/13 10:21:10", "2021/07/13 10:54:07", "2021/07/13 11:18:45" -->
<!--   ), -->
<!--   end = c( -->
<!--     "2021/07/13 12:02:39", "2021/07/13 13:20:17", -->
<!--     "2021/07/13 10:53:42", "2021/07/13 11:28:58", "2021/07/13 11:55:24" -->
<!--   ), -->
<!--   uuid = 1:5 -->
<!-- ) -->

<!-- test_data_w_duration <- test_data |> -->
<!--   add_duration()  -->

<!-- test_data_w_duration |> -->
<!--   knitr::kable()   -->

<!-- ## Second test -->
<!-- test_data_kobo_time <- data.frame( -->
<!--   `X.U.FEFF.start` = c( -->
<!--     "2021-07-13T11:25:49.543+03:00", -->
<!--     "2021-07-13T12:36:16.316+03:00", -->
<!--     "2021-07-13T10:21:10.337+03:00", -->
<!--     "2021-07-13T10:54:07.394+03:00", -->
<!--     "2021-07-13T11:18:45.521+03:00" -->
<!--   ), -->
<!--   end = c( -->
<!--     "2021-07-14T12:02:39.269+03:00", -->
<!--     "2021-07-13T13:20:17.815+03:00", -->
<!--     "2021-07-13T10:53:42.662+03:00", -->
<!--     "2021-07-13T11:28:58.295+03:00", -->
<!--     "2021-07-13T11:55:24.366+03:00" -->
<!--   ), -->
<!--   uuid_column = 1:5) -->


<!-- test_data_kobo_time_w_duration <- test_data_kobo_time |> -->
<!--                    add_duration(start_column = "X.U.FEFF.start") -->


<!-- test_data_kobo_time_w_duration |> -->
<!--   knitr::kable()   -->
<!-- ``` -->

<!-- ```{r tests-add_duration} -->
<!-- test_that("add_duration works", { -->
<!--   expect_true(inherits(add_duration, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## add_info_to_cleaning_log -->

<!-- ```{r function-add_info_to_cleaning_log} -->
<!-- #' add_info_to_cleaning_log -->
<!-- #'  -->
<!-- #' Add information to the cleaning log -->
<!-- #' -->
<!-- #' @param list_of_log A list file containing the cleaning_log and the dataset -->
<!-- #' @param dataset If a list is provided, the element name represents the dataset; otherwise, -->
<!-- #' it should be a dataframe. -->
<!-- #' @param cleaning_log If a list is provided, the element name represents the cleaning log; -->
<!-- #' otherwise, it is should be a dataframe. -->
<!-- #' @param dataset_uuid_column uuid column in the cleaning dataset, it can take a vector of several -->
<!-- #' binding key. Default is uuid. -->
<!-- #' @param cleaning_log_uuid_column uuid column in the cleaning log, it can take a vectore of several -->
<!-- #' binding key. Default is uuid. -->
<!-- #' @param information_to_add Vector of name of the columns to be added. -->
<!-- #' -->
<!-- #' @return A list with cleaning log with added info and the dataset. -->
<!-- #' @export -->

<!-- add_info_to_cleaning_log <- function(list_of_log = NULL, -->
<!--                                      dataset = "checked_dataset", -->
<!--                                      cleaning_log = "cleaning_log", -->
<!--                                      dataset_uuid_column = "uuid", -->
<!--                                      cleaning_log_uuid_column = "uuid", -->
<!--                                      information_to_add = c("enumerator_num", "date_assessment")) { -->
<!--   if (is.data.frame(list_of_log) & !is.null(list_of_log)) { -->
<!--     stop("The variable `list_of_log` represents a dataframe and can only take the values of either a list or NULL.") -->
<!--   } -->

<!--   if (!is.null(list_of_log)) { -->
<!--     if (!dataset %in% names(list_of_log)) { -->
<!--       stop(glue::glue("The element ", dataset, " is not present within the list_of_log.")) -->
<!--     } -->
<!--     if (!cleaning_log %in% names(list_of_log)) { -->
<!--       stop(glue::glue("The element ", cleaning_log, " is not present within the list_of_log.")) -->
<!--     } -->
<!--     dataset <- list_of_log[[dataset]] -->
<!--     cleaning_log <- list_of_log[[cleaning_log]] -->
<!--   } -->

<!--   if (is.null(list_of_log)) { -->
<!--     if (!is.data.frame(dataset)) { -->
<!--       stop(glue::glue("As the variable `list_of_log` is set to NULL, `dataset` must be a dataframe.")) -->
<!--     } -->

<!--     if (!is.data.frame(cleaning_log)) { -->
<!--       stop(glue::glue("As the variable `list_of_log` is set to NULL, `cleaning_log` must be a dataframe.")) -->
<!--     } -->
<!--   } -->

<!--   ## cleaning_log_info_check -->

<!--   if (any(!cleaning_log_uuid_column %in% names(cleaning_log))) { -->
<!--     stop( -->
<!--       cleaning_log_uuid_column[!cleaning_log_uuid_column %in% names(cleaning_log)] |> glue::glue_collapse(", ") %>% -->
<!--         glue::glue(., " can not be found in the cleaning log.") -->
<!--     ) -->
<!--   } -->

<!--   ## dataset info check -->
<!--   if (any(!information_to_add %in% names(dataset))) { -->
<!--     stop( -->
<!--       information_to_add[!c(information_to_add, dataset_uuid_column) %in% names(dataset)] |> glue::glue_collapse(", ") %>% -->
<!--         glue::glue(., " can not be found in the dataset.") -->
<!--     ) -->
<!--   } -->

<!--   dataset_raw <- dataset -->

<!--   dataset <- dataset |> dplyr::select(dplyr::all_of(information_to_add), dplyr::all_of(dataset_uuid_column)) -->
<!--   cleaning_log <- cleaning_log |> dplyr::select(-dplyr::any_of(information_to_add)) -->

<!--   cleaning_log <- merge(cleaning_log, dataset, -->
<!--     by.x = c(cleaning_log_uuid_column), -->
<!--     by.y = c(dataset_uuid_column), -->
<!--     all.x = TRUE -->
<!--   ) -->

<!--   output <- list() -->

<!--   output[["checked_dataset"]] <- dataset_raw -->
<!--   output[["cleaning_log"]] <- cleaning_log -->

<!--   output -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-add_info_to_cleaning_log} -->
<!--  ## An example of pipeline -->
<!-- cleaningtools::cleaningtools_raw_data |> -->
<!--   check_pii(uuid_column = "X_uuid") |> -->
<!--   check_duplicate(uuid_column = "X_uuid") |> -->
<!--   check_value(uuid_column = "X_uuid") |> -->
<!--   ## After the check creating the log -->
<!--   create_combined_log() |> -->
<!--   add_info_to_cleaning_log(dataset_uuid_column = "X_uuid") |> -->
<!--   knitr::kable()   -->
<!-- ``` -->

<!-- ```{r tests-add_info_to_cleaning_log} -->
<!-- test_that("add_info_to_cleaning_log works", { -->
<!--   expect_true(inherits(add_info_to_cleaning_log, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## add_duration_from_audit -->

<!-- ```{r function-add_duration_from_audit} -->
<!-- #' Adds duration from the audit file -->
<!-- #' -->
<!-- #' Wrapper around create_duration_from_audit_with_start_end and -->
<!-- #' create_duration_from_audit_sum_all to add the duration to the dataset. -->
<!-- #' -->
<!-- #' @param dataset dataset to add the duration -->
<!-- #' @param col_name_prefix string character to be used for the prefix of new columns -->
<!-- #' @param uuid_column uuid column in the dataset. Default is uuid. -->
<!-- #' @param audit_list list of dataframe that are the audit file with the uuid of -->
<!-- #' each interview as name of the dataframe. -->
<!-- #' @param start_question character vector use for the starting question (optional) -->
<!-- #' @param end_question character vector use for the ending question (optional) -->
<!-- #' @param sum_all TRUE or FALSE if to add the time with sum all duration -->
<!-- #' -->
<!-- #' @return return the dataset with durations column added -->
<!-- #' @export -->

<!-- add_duration_from_audit <- function(dataset, -->
<!--                                     col_name_prefix = "duration_audit", -->
<!--                                     uuid_column = "uuid", -->
<!--                                     audit_list, -->
<!--                                     start_question = NULL, -->
<!--                                     end_question = NULL, -->
<!--                                     sum_all = TRUE) { -->
<!--   # checks input -->
<!--   if (is.null(start_question) & !is.null(end_question)) { -->
<!--     stop("start_question is missing") -->
<!--   } -->
<!--   if (!is.null(start_question) & is.null(end_question)) { -->
<!--     stop("end_question is missing") -->
<!--   } -->
<!--   if (!is.null(start_question) & !is.null(end_question)) { -->
<!--     new_names_start_end <- paste0(col_name_prefix, c("_start_end_ms", "_start_end_minutes")) -->
<!--     if (any(new_names_start_end %in% names(dataset))) { -->
<!--       msg <- glue::glue(col_name_prefix, " seems to be already used as name in your dataset.") -->
<!--       stop(msg) -->
<!--     } -->
<!--   } -->

<!--   if (sum_all) { -->
<!--     new_names_sum_all <- paste0(col_name_prefix, c("_sum_all_ms", "_sum_all_minutes")) -->
<!--     if (any(new_names_sum_all %in% names(dataset))) { -->
<!--       msg <- glue::glue(col_name_prefix, " seems to be already used as name in your dataset.") -->
<!--       stop(msg) -->
<!--     } -->
<!--   } -->

<!--   # calculate duration for each audit file -->
<!--   if (!is.null(start_question) & !is.null(end_question)) { -->
<!--     duration_with_start_end <- audit_list %>% -->
<!--       purrr::map(~ create_duration_from_audit_with_start_end(.x, -->
<!--         start_question = start_question, -->
<!--         end_question = end_question -->
<!--       )) %>% -->
<!--       purrr::set_names(names(audit_list)) %>% -->
<!--       do.call(rbind, .) %>% -->
<!--       `names<-`(new_names_start_end) %>% -->
<!--       dplyr::mutate(uuid = row.names(.)) -->
<!--   } -->

<!--   if (!uuid_column %in% names(dataset)) { -->
<!--     msg <- glue::glue(uuid_column, " variable cannot be found in the dataset.") -->
<!--     stop(msg) -->
<!--   } -->

<!--   if (all(!names(audit_list) %in% dataset[[uuid_column]])) { -->
<!--     stop("It seems no uuid are found as name of any data frame of audit list, make sure the data frame are saved with the uuid as name.") -->
<!--   } -->

<!--   audit_check <- audit_list %>% -->
<!--     purrr::map_lgl(function(xx) { -->
<!--       all(c("node", "start", "end", "event") %in% names(xx)) -->
<!--     }) %>% -->
<!--     all() -->
<!--   if (!audit_check) { -->
<!--     stop("Some columns are missing in the audits, please make sure to have at least event, node, start, end") -->
<!--   } -->

<!--   if (sum_all) { -->
<!--     duration_with_sum_all <- audit_list %>% -->
<!--       purrr::map(create_duration_from_audit_sum_all) %>% -->
<!--       purrr::set_names(names(audit_list)) %>% -->
<!--       do.call(rbind, .) %>% -->
<!--       `names<-`(new_names_sum_all) %>% -->
<!--       dplyr::mutate(uuid = row.names(.)) -->
<!--   } -->

<!--   if (exists("duration_with_sum_all")) { -->
<!--     dataset <- dataset %>% -->
<!--       dplyr::left_join(duration_with_sum_all, by = stats::setNames("uuid", uuid_column)) -->
<!--   } -->

<!--   if (exists("duration_with_start_end")) { -->
<!--     dataset <- dataset %>% -->
<!--       dplyr::left_join(duration_with_start_end, by = stats::setNames("uuid", uuid_column)) -->
<!--   } -->

<!--   return(dataset) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-add_duration_from_audit} -->

<!-- list_audit <- list( -->
<!--   uuid1 = data.frame( -->
<!--     event = c("form start", rep("question", 5)), -->
<!--     node = c("", paste0("/xx/question", 1:5)), -->
<!--     start = c( -->
<!--       1661415887295, 1661415887301, -->
<!--       1661415890819, 1661415892297, -->
<!--       1661415893529, 1661415894720 -->
<!--     ), -->
<!--     end = c( -->
<!--       NA, 1661415890790, 1661415892273, -->
<!--       1661415893506, 1661415894703, -->
<!--       1661415896452 -->
<!--     ) -->
<!--   ), -->
<!--   uuid2 = data.frame( -->
<!--     event = c("form start", rep("question", 5)), -->
<!--     node = c("", paste0("/xx/question", 1:5)), -->
<!--     start = c( -->
<!--       1661415887295, 1661415887301, 1661415890819, -->
<!--       1661415892297, 1661415893529, 1661415894720 -->
<!--     ), -->
<!--     end = c( -->
<!--       NA, 1661415890790, 1661415892273, -->
<!--       1661415893506, 1661415894703, 1661415896452 -->
<!--     ) -->
<!--   ) -->
<!-- ) -->

<!-- some_dataset <- data.frame( -->
<!--   X_uuid = c("uuid1", "uuid2"), -->
<!--   question1 = c("a", "b"), -->
<!--   question2 = c("a", "b"), -->
<!--   question3 = c("a", "b"), -->
<!--   question4 = c("a", "b"), -->
<!--   question5 = c("a", "b") -->
<!-- ) -->


<!-- add_duration_from_audit(some_dataset, -->
<!--                         uuid_column = "X_uuid", -->
<!--                         audit_list = list_audit)|> -->
<!--   knitr::kable()   -->


<!-- add_duration_from_audit(some_dataset, -->
<!--                         uuid_column = "X_uuid",  -->
<!--                         audit_list = list_audit, -->
<!--                         start_question = "question1", -->
<!--                         end_question = "question3", -->
<!--                         sum_all = FALSE) |> -->
<!--   knitr::kable()   -->

<!-- add_duration_from_audit(some_dataset, -->
<!--                         uuid_column = "X_uuid",  -->
<!--                         audit_list = list_audit, -->
<!--                         start_question = "question1", -->
<!--                         end_question = "question3", -->
<!--                         sum_all = TRUE) |> -->
<!--   knitr::kable()   -->
<!-- ``` -->

<!-- ```{r tests-add_duration_from_audit} -->
<!-- test_that("add_duration_from_audit works", { -->
<!--   expect_true(inherits(add_duration_from_audit, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- # CHECKS Functions   -->

<!-- ## check_duration -->

<!-- ```{r function-check_duration} -->
<!-- #' Check if duration is outside of a range -->
<!-- #' -->
<!-- #' Check if value is strictly inferior of the lower threshold or strictly -->
<!-- #' superior of the higher threshold. -->
<!-- #' -->
<!-- #' @param dataset a dataset to be check as a dataframe or a list with the -->
<!-- #' dataframe stored as "checked_dataset" -->
<!-- #' @param column_to_check string character with the name of the duration column -->
<!-- #' @param uuid_column uuid column in the dataset. Default is uuid. -->
<!-- #' @param log_name character string with name to give to the log -->
<!-- #' @param lower_bound lower value of the range (strictly inferior to) -->
<!-- #' @param higher_bound higher value of the range (strictly superior to) -->
<!-- #' -->
<!-- #' @return return a list with the dataset checked stored as checked_dataset and -->
<!-- #' a dataframe with the duration log -->
<!-- #' @export -->

<!-- check_duration <- function(dataset, -->
<!--                            column_to_check, -->
<!--                            uuid_column = "uuid", -->
<!--                            log_name = "duration_log", -->
<!--                            lower_bound = 25, -->
<!--                            higher_bound = 90) { -->
<!--   if (is.data.frame(dataset)) { -->
<!--     dataset <- list(checked_dataset = dataset) -->
<!--   } -->
<!--   if (!("checked_dataset" %in% names(dataset))) { -->
<!--     stop("Cannot identify the dataset in the list") -->
<!--   } -->

<!--   if (!(column_to_check %in% names(dataset[["checked_dataset"]]))) { -->
<!--     msg <- glue::glue("Cannot find ", column_to_check, " in the names of the dataset") -->
<!--     stop(msg) -->
<!--   } -->

<!--   log <- dataset[["checked_dataset"]] %>% -->
<!--     dplyr::mutate(duration_check = !!rlang::sym(column_to_check) < lower_bound | -->
<!--       !!rlang::sym(column_to_check) > higher_bound) %>% -->
<!--     dplyr::filter(duration_check) %>% -->
<!--     dplyr::select(dplyr::all_of(c(uuid_column, column_to_check))) %>% -->
<!--     dplyr::mutate( -->
<!--       question = column_to_check, -->
<!--       issue = "Duration is lower or higher than the thresholds" -->
<!--     ) %>% -->
<!--     dplyr::rename( -->
<!--       old_value = !!rlang::sym(column_to_check), -->
<!--       uuid = !!rlang::sym(uuid_column) -->
<!--     ) -->

<!--   dataset[[log_name]] <- log -->
<!--   return(dataset) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-check_duration} -->

<!-- testdata <- data.frame( -->
<!--   uuid = c(letters[1:7]), -->
<!--   duration_audit_start_end_ms = c( -->
<!--     2475353, 375491, 2654267, 311585, 817270, -->
<!--     2789505, 8642007 -->
<!--   ), -->
<!--   duration_audit_start_end_minutes = c(41, 6, 44, 5, 14, 46, 144) -->
<!-- ) -->

<!-- check_duration(testdata, -->
<!--                 column_to_check = "duration_audit_start_end_minutes") |> -->
<!--   knitr::kable()   -->

<!-- check_duration( testdata, -->
<!--                 column_to_check = "duration_audit_start_end_ms", -->
<!--                 lower_bound = 375490, -->
<!--                 higher_bound = 8642000) |> -->
<!--   knitr::kable()   -->

<!-- testdata %>% -->
<!--   check_duration(column_to_check = "duration_audit_start_end_minutes") %>% -->
<!--   check_duration( column_to_check = "duration_audit_start_end_ms", -->
<!--                   log_name = "duration_in_ms", -->
<!--                   lower_bound = 375490, -->
<!--                   higher_bound = 8642000  )|> -->
<!--   knitr::kable()   -->
<!-- ``` -->

<!-- ```{r tests-check_duration} -->
<!-- test_that("check_duration works", { -->
<!--   expect_true(inherits(check_duration, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## check_duplicate -->

<!-- ```{r function-check_duplicate} -->
<!-- #' Checks for duplicated values in columns -->
<!-- #' -->
<!-- #' @param dataset dataset to be check as a dataframe or a list with the dataframe stored as -->
<!-- #' "checked_dataset". -->
<!-- #' @param uuid_column uuid column in the dataset. Default is uuid. -->
<!-- #' @param columns_to_check string character with the name of the columns to check. If NULL (default), -->
<!-- #' it will check for the uuid_column -->
<!-- #' @param log_name name of the log of flagged value -->
<!-- #' -->
<!-- #' @return return a list with the dataset checked stored as checked_dataset and -->
<!-- #' a dataframe with the duplicate log -->
<!-- #' @export -->

<!-- check_duplicate <- function(dataset, -->
<!--                             uuid_column = "uuid", -->
<!--                             columns_to_check = NULL, -->
<!--                             log_name = "duplicate_log") { -->
<!--   if (is.data.frame(dataset)) { -->
<!--     dataset <- list(checked_dataset = dataset) -->
<!--   } -->
<!--   if (!("checked_dataset" %in% names(dataset))) { -->
<!--     stop("Cannot identify the dataset in the list") -->
<!--   } -->

<!--   if (!(uuid_column %in% names(dataset[["checked_dataset"]]))) { -->
<!--     msg <- glue::glue("Cannot find ", uuid_column, " in the names of the dataset") -->
<!--     stop(msg) -->
<!--   } -->

<!--   if (is.null(columns_to_check)) { -->
<!--     columns_to_check <- uuid_column -->
<!--     check_only_uuid <- TRUE -->
<!--   } else { -->
<!--     check_only_uuid <- FALSE -->
<!--   } -->

<!--   if (!all(columns_to_check %in% names(dataset[["checked_dataset"]]))) { -->
<!--     msg <- glue::glue( -->
<!--       "Cannot find ", -->
<!--       { -->
<!--         glue::glue_collapse(columns_to_check, sep = " ~/~ ") -->
<!--       }, -->
<!--       " in the names of the dataset" -->
<!--     ) -->
<!--     stop(msg) -->
<!--   } -->

<!--   duplicate_log <- dataset[["checked_dataset"]] %>% -->
<!--     dplyr::mutate(dplyr::across(.cols = dplyr::everything(), .fns = as.character)) %>% -->
<!--     tidyr::unite(unique_combination, dplyr::all_of(columns_to_check), remove = F) %>% -->
<!--     dplyr::mutate(duplicate_check = duplicated(unique_combination)) %>% -->
<!--     dplyr::filter(duplicate_check) %>% -->
<!--     dplyr::select(dplyr::all_of(c(uuid_column, columns_to_check))) -->

<!--   if (check_only_uuid) { -->
<!--     duplicate_log <- duplicate_log %>% -->
<!--       dplyr::mutate( -->
<!--         old_value = !!rlang::sym(columns_to_check), -->
<!--         question = columns_to_check, -->
<!--         issue = glue::glue("duplicated ", columns_to_check) -->
<!--       ) %>% -->
<!--       dplyr::rename(uuid = !!rlang::sym(uuid_column)) -->
<!--   } else { -->
<!--     duplicate_log <- duplicate_log %>% -->
<!--       tidyr::pivot_longer(!dplyr::all_of(uuid_column), -->
<!--         names_to = "question", -->
<!--         values_to = "old_value" -->
<!--       ) %>% -->
<!--       dplyr::mutate( -->
<!--         issue = glue::glue("duplicated ", { -->
<!--           glue::glue_collapse(columns_to_check, sep = " ~/~ ") -->
<!--         }) -->
<!--       ) %>% -->
<!--       dplyr::rename(uuid = !!rlang::sym(uuid_column)) -->
<!--   } -->

<!--   dataset[[log_name]] <- duplicate_log -->
<!--   return(dataset) -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-check_duplicate} -->

<!-- testdata <- data.frame( -->
<!--   uuid = c(letters[1:4], "a", "b", "c"), -->
<!--   col_a = runif(7), -->
<!--   col_b = runif(7) -->
<!-- ) -->

<!-- check_duplicate(testdata) |> -->
<!--   knitr::kable()   -->

<!-- testdata2 <- data.frame( -->
<!--   uuid = letters[c(1:7)], -->
<!--   village = paste("village", c(1:3, 1:3, 4)), -->
<!--   ki_identifier = paste0("xx_", c(1:5, 3, 4)) -->
<!-- ) -->

<!-- check_duplicate(testdata2,  -->
<!--                 columns_to_check = "village") |> -->
<!--   knitr::kable()   -->

<!-- check_duplicate(testdata2,  -->
<!--                 columns_to_check = c("village", "ki_identifier"), -->
<!--                 uuid = "uuid") |> -->
<!--   knitr::kable()   -->

<!-- ``` -->

<!-- ```{r tests-check_duplicate} -->
<!-- test_that("check_duplicate works", { -->
<!--   expect_true(inherits(check_duplicate, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## check_fcs -->

<!-- ```{r function-check_fcs} -->
<!-- #' FCS component checks -->
<!-- #'  -->
<!-- #' @param dataset dataset to be check as a dataframe or a list with the dataframe stored as "checked_dataset" -->
<!-- #' @param uuid_column uuid column in the dataset. Default is uuid. -->
<!-- #' @param cereals_column Variable name for- In the last 7 days, on how many days did your household eat cereals, grains, roots and tubers, including wild roots? -->
<!-- #' @param pulses_column Variable name for-  In the last 7 days, on how many days did your household eat any beans / legumes, pulses or nuts? -->
<!-- #' @param dairy_column Variable name for- In the last 7 days, on how many days did your household drink milk or eat other dairy products? -->
<!-- #' @param meat_column  Variable name for-  In the last 7 days, on how many days did your household eat meat, fish or eggs? -->
<!-- #' @param vegetables_column Variable name for- In the last 7 days, on how many days did your household eat vegetables or leaves, including all wild vegetables and leaves? -->
<!-- #' @param fruits_column Variable name for- In the last 7 days, on how many days did your household eat fruits, including all wild fruits? -->
<!-- #' @param oil_column Variable name for- In the last 7 days, on how many days did your household eat oil, fat, or butter? -->
<!-- #' @param sugar_column Variable name for- In the last 7 days, on how many days did your household eat sugar or sugary foods? -->
<!-- #' @return dataset with potential issues -->
<!-- #' @export -->

<!-- check_fcs <- function(dataset, -->
<!--                       uuid_column = "uuid", -->
<!--                       cereals_column = "fs_fcs_cerealgrainroottuber", -->
<!--                       pulses_column = "fs_fcs_beansnuts", -->
<!--                       dairy_column = "fs_fcs_dairy", -->
<!--                       meat_column = "fs_fcs_meatfishegg", -->
<!--                       vegetables_column = "fs_fcs_vegetableleave", -->
<!--                       fruits_column = "fs_fcs_fruit", -->
<!--                       oil_column = "fs_fcs_fat", -->
<!--                       sugar_column = "fs_fcs_sugar") { -->
<!--   fcs_cols <- c( -->
<!--     cereals_column, pulses_column, dairy_column, meat_column, vegetables_column, -->
<!--     fruits_column, oil_column, sugar_column -->
<!--   ) -->

<!--   check_df <- dataset %>% -->
<!--     dplyr::filter(pmax(!!!rlang::syms(fcs_cols), na.rm = T) == pmin(!!!rlang::syms(fcs_cols), na.rm = T)) %>% -->
<!--     dplyr::select(!!rlang::sym(uuid_column), dplyr::all_of(fcs_cols)) %>% -->
<!--     dplyr::mutate( -->
<!--       issue = "All the vlaues of of food consumption variables are the same" -->
<!--     ) ## filtering only observation where all the values are same. Didn't use if_all to consider NA. -->

<!--   warring_ma <- paste0("Potential issue ! There are ", nrow(check_df), " observations where all the variables of food consumption score are the same.Check result.") -->

<!--   if (nrow(check_df) > 0) { -->
<!--     warning(warring_ma) -->
<!--   } -->

<!--   if (nrow(check_df) == 0) { -->
<!--     print("No issue found") -->
<!--   } -->
<!--   check_df -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-check_fcs} -->
<!-- #check_fcs() -->
<!-- ``` -->

<!-- ```{r tests-check_fcs} -->
<!-- test_that("check_fcs works", { -->
<!--   expect_true(inherits(check_fcs, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## check_logical -->

<!-- ```{r function-check_logical} -->
<!-- #' Check a logical test -->
<!-- #' -->
<!-- #' @param dataset dataset to be check as a dataframe or a list with the dataframe stored as -->
<!-- #' "checked_dataset" -->
<!-- #' @param uuid_column uuid column in the dataset. Default is "uuid". -->
<!-- #' @param information_to_add string vector optional, if to add some information to the log -->
<!-- #' (today, vilagge) -->
<!-- #' @param check_id name of the check to perform -->
<!-- #' @param check_to_perform test to perform as R code (in text format) -->
<!-- #' @param columns_to_clean variables to be put in the log. if not provided, it will try to detect -->
<!-- #' variables -->
<!-- #' @param description description of the check performed -->
<!-- #' -->
<!-- #' @return return a list with the dataset checked stored as checked_dataset, it will have all -->
<!-- #' a column added with the check_id  and a dataframe with the logical check log. -->
<!-- #' @export -->

<!-- check_logical <- function(dataset, -->
<!--                           uuid_column = "uuid", -->
<!--                           information_to_add = NULL, -->
<!--                           check_id = "logical_xx", -->
<!--                           check_to_perform, -->
<!--                           columns_to_clean = NULL, -->
<!--                           description) { -->
<!--   if (is.data.frame(dataset)) { -->
<!--     dataset <- list(checked_dataset = dataset) -->
<!--   } -->
<!--   if (!("checked_dataset" %in% names(dataset))) { -->
<!--     stop("Cannot identify the dataset in the list") -->
<!--   } -->

<!--   if (check_id %in% names(dataset[["checked_dataset"]])) { -->
<!--     msg <- glue::glue(check_id, " is in the names of the dataset, please change check id name.") -->
<!--     stop(msg) -->
<!--   } -->

<!--   if (is.na(description) | description == "") { -->
<!--     msg <- "description cannot be empty" -->
<!--     stop(msg) -->
<!--   } -->

<!--   if (any(is.null(columns_to_clean), is.na(columns_to_clean), columns_to_clean == "")) { -->
<!--     msg <- "columns_to_clean not shared, results may not be accurate" -->
<!--     warning(msg) -->
<!--     tentative_var <- detect_variable(check_to_perform) -->
<!--     variables_across_by <- c(tentative_var, information_to_add) %>% -->
<!--       stringr::str_split(",", simplify = T) %>% -->
<!--       stringr::str_trim() %>% -->
<!--       as.vector() -->
<!--     variables_across_by <- variables_across_by[variables_across_by != ""] -->
<!--   } -->

<!--   if (!any(is.null(columns_to_clean), is.na(columns_to_clean), columns_to_clean == "")) { -->
<!--     variables_across_by <- c(columns_to_clean, information_to_add) %>% -->
<!--       stringr::str_split(",", simplify = T) %>% -->
<!--       stringr::str_trim() %>% -->
<!--       as.vector() -->
<!--     variables_across_by <- variables_across_by[variables_across_by != ""] -->
<!--   } -->

<!--   dataset[["checked_dataset"]] <- dataset[["checked_dataset"]] %>% -->
<!--     dplyr::mutate(!!rlang::sym(as.character(check_id)) := eval(parse(text = check_to_perform))) -->

<!--   trimmed_dataset <- dataset[["checked_dataset"]] %>% -->
<!--     dplyr::filter(!!rlang::sym(check_id)) %>% -->
<!--     dplyr::mutate(uuid := !!rlang::sym(uuid_column)) %>% -->
<!--     dplyr::select(dplyr::all_of(c("uuid", variables_across_by))) -->

<!--   if (exists("tentative_var")) { -->
<!--     if (length(tentative_var) == 0) { -->
<!--       dataset[[check_id]] <- trimmed_dataset %>% -->
<!--         dplyr::mutate(dplyr::across(.cols = dplyr::everything(), .fns = ~ format(., scientific = F, justify = "none", trim = T)), -->
<!--           question = "unable to identify", -->
<!--           old_value = "please check this uuid for this check", -->
<!--           issue = description, -->
<!--           check_id = check_id, -->
<!--           check_binding = paste(check_id, uuid, sep = " ~/~ ") -->
<!--         ) -->
<!--       return(dataset) -->
<!--     } -->
<!--   } -->

<!--   dataset[[check_id]] <- trimmed_dataset %>% -->
<!--     dplyr::mutate(dplyr::across(.cols = dplyr::everything(), .fns = ~ format(., scientific = F, justify = "none", trim = T))) %>% -->
<!--     tidyr::pivot_longer(cols = !dplyr::all_of(c("uuid", information_to_add)), names_to = "question", values_to = "old_value") %>% -->
<!--     dplyr::mutate( -->
<!--       issue = description, -->
<!--       check_id = check_id, -->
<!--       check_binding = paste(check_id, uuid, sep = " ~/~ ") -->
<!--     ) -->
<!--   return(dataset) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-check_logical} -->

<!-- test_data <- data.frame( -->
<!--   uuid = c(1:10) %>% as.character(), -->
<!--   today = rep("2023-01-01", 10), -->
<!--   location = rep(c("villageA", "villageB"), 5), -->
<!--   distance_to_market = c(rep("less_30", 5), rep("more_30", 5)), -->
<!--   access_to_market = c(rep("yes", 4), rep("no", 6)), -->
<!--   number_children_05 = c(rep(c(0, 1), 4), 5, 6) ) -->

<!-- check_logical(test_data, -->
<!--   uuid_column = "uuid", -->
<!--   check_id = "my_test", -->
<!--   check_to_perform = "distance_to_market == \"less_30\" & access_to_market == \"no\"", -->
<!--   columns_to_clean = "distance_to_market, access_to_market", -->
<!--   description = "distance to market less than 30 and no access") |> -->
<!--   knitr::kable()   -->

<!-- check_logical(test_data, -->
<!--   uuid_column = "uuid", -->
<!--   information_to_add = c("today", "location"), -->
<!--   check_to_perform = "distance_to_market == \"less_30\" & access_to_market == \"no\"", -->
<!--   columns_to_clean = "distance_to_market, access_to_market", -->
<!--   description = "distance to market less than 30 and no access")|> -->
<!--   knitr::kable()   -->
<!-- ``` -->

<!-- ```{r tests-check_logical} -->
<!-- test_that("check_logical works", { -->
<!--   expect_true(inherits(check_logical, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## check_logical_with_list -->

<!-- ```{r function-check_logical_with_list} -->
<!-- #' Check several logical test -->
<!-- #' -->
<!-- #' This is a wrapper around check_logical to allow several checks to be performed. -->
<!-- #' -->
<!-- #' @param dataset dataset to be check as a dataframe or a list with the dataframe stored as -->
<!-- #' "checked_dataset" -->
<!-- #' @param uuid_column uuid column in the dataset. Default is "uuid". -->
<!-- #' @param information_to_add string vector optional, if to add some information to the log (today, vilagge) -->
<!-- #' @param list_of_check a dataframe with the checks to perform -->
<!-- #' @param check_id_column the column name with the names of each test. -->
<!-- #' @param check_to_perform_column the column name with the checks to perform as R code (in text format) -->
<!-- #' @param columns_to_clean_column the column name with the variables to be put in the log. -->
<!-- #' @param description_column the column name with the description -->
<!-- #' @param bind_checks default is TRUE, to bind the checks into 1 log. -->
<!-- #' -->
<!-- #' @return return a list with the dataset checked stored as checked_dataset, it will have all -->
<!-- #' a column added with the check_id  and a dataframe with the logical check log. -->
<!-- #' @export -->

<!-- check_logical_with_list <- function(dataset, -->
<!--                                     uuid_column = "uuid", -->
<!--                                     information_to_add = NULL, -->
<!--                                     list_of_check, -->
<!--                                     check_id_column, -->
<!--                                     check_to_perform_column, -->
<!--                                     columns_to_clean_column = NULL, -->
<!--                                     description_column, -->
<!--                                     bind_checks = TRUE) { -->

<!--   if (any(duplicated(list_of_check[[check_id_column]]))) { -->
<!--     msg <- glue::glue("The column ", check_id_column, " from the checklist contains duplicated.") -->
<!--     stop(msg) -->
<!--   } -->

<!--   if (is.data.frame(dataset)) { -->
<!--     dataset <- list(checked_dataset = dataset) -->
<!--   } -->
<!--   if (!("checked_dataset" %in% names(dataset))) { -->
<!--     stop("Cannot identify the dataset in the list") -->
<!--   } -->

<!--   # to be used to reduce -->
<!--   initial_names <- names(dataset[["checked_dataset"]]) -->

<!--   if (any(is.null(columns_to_clean_column), is.na(columns_to_clean_column), columns_to_clean_column == "")) { -->
<!--     list_of_check[["columns_to_clean_column"]] <- NA_character_ -->
<!--     columns_to_clean_column <- "columns_to_clean_column" -->
<!--   } -->

<!--   # split the check in a list and map check_logical -->
<!--   log_of_logical_checks <- list_of_check %>% -->
<!--     dplyr::mutate(!!rlang::sym(check_id_column) := as.character(!!rlang::sym(check_id_column))) %>% -->
<!--     dplyr::group_by(!!rlang::sym(check_id_column)) %>% -->
<!--     dplyr::group_split() %>% -->
<!--     purrr::map(~ check_logical( -->
<!--       dataset = dataset, -->
<!--       uuid_column = uuid_column, -->
<!--       information_to_add = information_to_add, -->
<!--       check_id = .[[check_id_column]], -->
<!--       check_to_perform = .[[check_to_perform_column]], -->
<!--       columns_to_clean = .[[columns_to_clean_column]], -->
<!--       description = .[[description_column]] -->
<!--     )) %>% -->
<!--     purrr::set_names(list_of_check[[check_id_column]]) -->


<!--   dataset[["checked_dataset"]] <- log_of_logical_checks %>% -->
<!--     purrr::map(function(xx) xx[["checked_dataset"]]) %>% -->
<!--     purrr::reduce(dplyr::left_join, by = initial_names) -->

<!--   log_from_check <- log_of_logical_checks %>% -->
<!--     purrr::map(~ purrr::keep(., names(.) %in% list_of_check[[check_id_column]])) %>% -->
<!--     purrr::map(dplyr::bind_rows) -->

<!--   if (bind_checks == FALSE) { -->
<!--     dataset <- append(dataset, log_from_check) -->
<!--   } else { -->
<!--     dataset[["logical_all"]] <- log_from_check %>% purrr::reduce(dplyr::bind_rows) -->
<!--   } -->

<!--   return(dataset) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-check_logical_with_list} -->

<!-- test_data <- data.frame( -->
<!--   uuid = c(1:10) %>% as.character(), -->
<!--   distance_to_market = rep(c("less_30", "more_30"), 5), -->
<!--   access_to_market = c(rep("yes", 4), rep("no", 6)), -->
<!--   number_children_05 = c(rep(c(0, 1), 4), 5, 6), -->
<!--   number_children_618 = c(rep(c(0, 1), 4), 5, 6) -->
<!-- ) -->

<!-- check_list <- data.frame( -->
<!--   name = c("logical_xx", "logical_yy", "logical_zz"), -->
<!--   check = c( -->
<!--     "distance_to_market == \"less_30\" & access_to_market == \"no\"", -->
<!--     "number_children_05 > 3", -->
<!--     "rowSums(dplyr::across(starts_with(\"number\")), na.rm = T) > 9" -->
<!--   ), -->
<!--   description = c( -->
<!--     "distance to market less than 30 and no access", -->
<!--     "number of children under 5 seems high", -->
<!--     "number of children very high" -->
<!--   ), -->
<!--   columns_to_clean = c( -->
<!--     "distance_to_market, access_to_market", -->
<!--     "number_children_05", -->
<!--     "" -->
<!--   ) -->
<!-- ) -->

<!-- check_logical_with_list(test_data, -->
<!--   uuid_column = "uuid", -->
<!--   list_of_check = check_list, -->
<!--   check_id_column = "name", -->
<!--   check_to_perform_column = "check", -->
<!--   columns_to_clean_column = "columns_to_clean", -->
<!--   description_column = "description") |> -->
<!--   knitr::kable()   -->

<!-- ``` -->

<!-- ```{r tests-check_logical_with_list} -->
<!-- test_that("check_logical_with_list works", { -->
<!--   expect_true(inherits(check_logical_with_list, "function"))  -->
<!-- }) -->
<!-- ``` -->


<!-- ## check_others_checks -->

<!-- ```{r function-check_others_checks} -->
<!-- #' Check if the input passed to the check_others function is correct -->
<!-- #' -->
<!-- #' @param dataset dataset to be check as a dataframe or a list with the dataframe stored as "checked_dataset" -->
<!-- #' @param uuid_column uuid column in the dataset. Default is uuid. -->
<!-- #' @param columns_to_check Columns to include in the checks -->
<!-- #' -->
<!-- #' @return nothing -->
<!-- #' @export -->
<!-- #' -->

<!-- check_others_checks <- function(dataset, uuid_column, columns_to_check) { -->
<!--   if (!(uuid_column %in% names(dataset))) { -->
<!--     stop("uuid column is missing") -->
<!--   } -->

<!--   if (is.null(columns_to_check)) { -->
<!--     stop("provide the list of follow up questions") -->
<!--   } -->

<!--   if (!is.null(columns_to_check) & any(!columns_to_check %in% names(dataset))) { -->
<!--     stop("at least one variable is missing from the dataset") -->
<!--   } -->

<!--   if (!is.null(columns_to_check) & any(!columns_to_check %in% names(dataset))) { -->
<!--     stop("at least one variable is missing from the dataset") -->
<!--   } -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-check_others_checks} -->
<!-- #check_others_checks() -->
<!-- ``` -->

<!-- ```{r tests-check_others_checks} -->
<!-- test_that("check_others_checks works", { -->
<!--   expect_true(inherits(check_others_checks, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## check_others -->

<!-- ```{r function-check_others} -->
<!-- #' Generate a log for other follow up questions -->
<!-- #' -->
<!-- #' @param dataset dataset to be check as a dataframe or a list with the dataframe stored as "checked_dataset" -->
<!-- #' @param uuid_column uuid column in the dataset. Default is "uuid". -->
<!-- #' @param columns_to_check Columns to include in the checks -->
<!-- #' -->
<!-- #' @return a log with all the values that may require recoding -->
<!-- #' @export -->

<!-- check_others <- function(dataset, -->
<!--                          uuid_column = "uuid", -->
<!--                          columns_to_check = NULL) { -->
<!--   input_is_list <- F -->

<!--   if (is.list(dataset) & !is.data.frame(dataset)) { -->
<!--     if (!"checked_dataset" %in% names(dataset)) { -->
<!--       stop("the dataset in the list should be named 'checked_dataset'") -->
<!--     } -->

<!--     input_is_list <- T -->
<!--     input_list <- dataset -->
<!--     dataset <- dataset$checked_dataset -->
<!--   } -->

<!--   check_others_checks(dataset, uuid_column, columns_to_check) -->


<!--   other_log <- dataset %>% -->
<!--     dplyr::select(uuid := !!rlang::sym(uuid_column), dplyr::all_of(columns_to_check)) %>% -->
<!--     tidyr::pivot_longer(cols = -c("uuid"), names_to = "question", values_to = "old_value") %>% -->
<!--     dplyr::filter(!is.na(old_value) & old_value != "") %>% -->
<!--     dplyr::mutate( -->
<!--       issue = "recode other" -->
<!--     ) -->

<!--   if (input_is_list) { -->
<!--     input_list$other_log <- other_log -->
<!--     return(input_list) -->
<!--   } else { -->
<!--     return(list( -->
<!--       checked_dataset = dataset, -->
<!--       other_log = other_log -->
<!--     )) -->
<!--   } -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-check_others} -->

<!-- check_others.this <- check_others( -->
<!--   dataset = cleaningtools::cleaningtools_clean_data, -->
<!--   uuid_column = "X_uuid", -->
<!--   columns_to_check = names(cleaningtools::cleaningtools_clean_data |> -->
<!--     dplyr::select(ends_with("_other")) |> -->
<!--     dplyr::select(-contains("."))) -->
<!-- )  -->

<!-- check_others.this  -->

<!-- check_others.this |> -->
<!--   knitr::kable()   -->
<!-- ``` -->

<!-- ```{r tests-check_others} -->
<!-- test_that("check_others works", { -->
<!--   expect_true(inherits(check_others, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## check_outliers -->

<!-- ```{r function-check_outliers} -->
<!-- #' check outliers over the dataset -->
<!-- #' -->
<!-- #' @param dataset dataset to be check as a dataframe or a list with the dataframe stored as -->
<!-- #' "checked_dataset" -->
<!-- #' @param kobo_survey Kobo survey sheet. Default is NULL. -->
<!-- #' @param kobo_choices Kobo choices sheet. Default is NULL. -->
<!-- #' @param uuid_column UUID. Default is uuid -->
<!-- #' @param element_name name of the dataset in list -->
<!-- #' @param cols_to_add_cleaning_log Variables those must be included in the output -->
<!-- #' @param strongness_factor Strongness factor define how strong your outliers will be. The default is 3. -->
<!-- #' @param columns_not_to_check Columns to exclude from the checks even if they are numeric values. -->
<!-- #' @param remove_choice_multiple TRUE (default) will remove choice multiple questions from the output. -->
<!-- #' @param sm_separator Separator for choice multiple questions. The default is "." -->
<!-- #' @param minimum_unique_value_of_variable Default is NULL, mean this parameter won't be considered. For example 10 means for any variable where number of unique value is less than 10, then the variable won't be considered for outlier checking. -->
<!-- #' @return return a list with the dataset checked stored as checked_dataset and a dataframe with -->
<!-- #' the outliers log -->
<!-- #' @export -->

<!-- check_outliers <- function(dataset, -->
<!--                            uuid_column = "uuid", -->
<!--                            element_name = "checked_dataset", -->
<!--                            kobo_survey = NULL, -->
<!--                            kobo_choices = NULL, -->
<!--                            cols_to_add_cleaning_log = NULL, -->
<!--                            strongness_factor = 3, -->
<!--                            minimum_unique_value_of_variable = NULL, -->
<!--                            remove_choice_multiple = TRUE, -->
<!--                            sm_separator = ".", -->
<!--                            columns_not_to_check = NULL) { -->
<!--   if (!is.list(dataset)) { -->
<!--     stop("Input must be a dataframe or list.") -->
<!--   } -->
<!--   if (is.null(kobo_survey) & !is.null(kobo_choices)) { -->
<!--     warning("Ignoring perameter `kobo_choices` as `kobo_survey` is not provided.") -->
<!--   } -->
<!--   if (is.null(kobo_choices) & !is.null(kobo_survey)) { -->
<!--     warning("Ignoring perameter `kobo_survey` as `kobo_choices` is not provided.") -->
<!--   } -->

<!--   ######### checking input -->
<!--   dataframe <- dataset -->

<!--   if (!is.data.frame(dataset) & is.list(dataset)) { -->
<!--     if (is.null(element_name)) { -->
<!--       stop("element_name is missing") -->
<!--     } -->
<!--     if (!element_name %in% names(dataset)) { -->
<!--       stop("element_name not found") -->
<!--     } -->
<!--   } -->

<!--   if (!is.data.frame(dataset) & is.list(dataset)) { -->
<!--     dataset <- dataset[[element_name]] -->
<!--   } -->

<!--   ####################### -->


<!--   dataset <- utils::type.convert(dataset, as.is = TRUE, na.string = c("", " ")) |> -->
<!--     dplyr::rename( -->
<!--       uuid = !!rlang::sym(uuid_column) -->
<!--     ) |> -->
<!--     dplyr::mutate(uuid = as.character(uuid)) -->

<!--   cols_to_add_cleaning_log <- c(cols_to_add_cleaning_log, "uuid") |> unique() -->



<!--   if (remove_choice_multiple == T) { -->
<!--     all_select_multiple_parent <- auto_sm_parent_children(dataset, sm_separator = sm_separator) -->
<!--     all_select_multiple_cols <- all_select_multiple_parent$sm_child -->
<!--   } -->

<!--   if (remove_choice_multiple == T) { -->
<!--     columns_not_to_check <- c(columns_not_to_check, all_select_multiple_cols) -->
<!--   } -->

<!--   cols_to_remove <- columns_not_to_check[!columns_not_to_check %in% cols_to_add_cleaning_log] -->




<!--   if (!is.null(cols_to_remove)) { -->
<!--     dataset <- dataset %>% dplyr::select(-dplyr::all_of(cols_to_remove)) -->
<!--   } -->



<!--   if (!is.null(kobo_survey) & !is.null(kobo_choices)) { -->
<!--     kobo_survey$name <- kobo_survey$name %>% stringr::str_replace_all("-", ".") -->


<!--     interger_column_in_kobo <- (kobo_survey %>% dplyr::filter(type == "integer") %>% -->
<!--       dplyr::filter(!grepl("enumerator|_instance_|index", name)))$name -->

<!--     cols_name_exist_in_loop_kobo <- interger_column_in_kobo[interger_column_in_kobo %in% names(dataset)] -->
<!--   } -->

<!--   cols_name_exist_in_loop_numeric <- dataset %>% -->
<!--     dplyr::select_if(is.numeric) %>% -->
<!--     dplyr::select(-dplyr::starts_with("X")) %>% -->
<!--     names() -->
<!--   cols_name_exist_in_loop_int <- dataset %>% -->
<!--     dplyr::select_if(is.integer) %>% -->
<!--     dplyr::select(-dplyr::starts_with("X")) %>% -->
<!--     names() -->

<!--   if (!is.null(kobo_survey) & !is.null(kobo_choices)) { -->
<!--     cols_name_exist_in_loop <- c( -->
<!--       cols_name_exist_in_loop_kobo, -->
<!--       cols_name_exist_in_loop_numeric, ## added in case of new recoded variables -->
<!--       cols_name_exist_in_loop_int -->
<!--     ) %>% unique() -->
<!--   } -->




<!--   if (is.null(kobo_survey) | is.null(kobo_choices)) { -->
<!--     cols_name_exist_in_loop <- c( -->
<!--       cols_name_exist_in_loop_numeric, -->
<!--       cols_name_exist_in_loop_int -->
<!--     ) %>% unique() -->
<!--   } -->

<!--   outlier_checks <- list() -->

<!--   for (x in cols_name_exist_in_loop) { -->
<!--     print(paste0("checking_", x)) -->

<!--     dataset[[x]] <- dataset[[x]] %>% as.numeric() -->
<!--     variable_value <- dataset[[x]] -->

<!--     variable_value <- variable_value[!is.na(variable_value) & !is.null(variable_value) & !is.infinite(variable_value)] -->

<!--     if (!is.null(minimum_unique_value_of_variable)) { -->
<!--       outliers_tf_nr <- (abs(variable_value - mean(variable_value)) > strongness_factor * stats::sd(variable_value)) & -->
<!--         (length(unique(variable_value)) > minimum_unique_value_of_variable) -->
<!--     } -->


<!--     if (is.null(minimum_unique_value_of_variable)) { -->
<!--       outliers_tf_nr <- abs(variable_value - mean(variable_value)) > strongness_factor * stats::sd(variable_value) -->
<!--     } -->



<!--     outliers_value <- variable_value[outliers_tf_nr] %>% unique() -->



<!--     outlier_checks[[x]] <- dataset %>% -->
<!--       dplyr::mutate( -->
<!--         issue = dplyr::case_when(dataset[[x]] %in% outliers_value ~ "outlier (normal distribution)"), -->
<!--       ) %>% -->
<!--       dplyr::filter(issue == "outlier (normal distribution)") %>% -->
<!--       dplyr::select(dplyr::all_of(cols_to_add_cleaning_log), issue, dplyr::all_of(x)) %>% -->
<!--       tidyr::pivot_longer(cols = paste0(x), names_to = "question", values_to = "old_value") -->



<!--     #### log checks #### -->

<!--     dataset[["log"]] <- log(dataset[[x]] + 1) -->


<!--     log_variable <- dataset[["log"]] -->
<!--     log_variable <- log_variable[!is.na(log_variable) & !is.null(log_variable) & !is.infinite(log_variable)] -->

<!--     if (!is.null(minimum_unique_value_of_variable)) { -->
<!--       outliers_tf <- abs(log_variable - mean(log_variable)) > strongness_factor * stats::sd(log_variable) & -->
<!--         length(unique(log_variable)) > minimum_unique_value_of_variable -->
<!--     } -->

<!--     if (is.null(minimum_unique_value_of_variable)) { -->
<!--       outliers_tf <- abs(log_variable - mean(log_variable)) > strongness_factor * stats::sd(log_variable) -->
<!--     } -->



<!--     outliers_value_log <- log_variable[outliers_tf] %>% unique() -->



<!--     outlier_checks[[paste0("log_", x)]] <- dataset %>% -->
<!--       dplyr::mutate( -->
<!--         issue = dplyr::case_when(dataset[["log"]] %in% outliers_value_log ~ "outlier (log distribution)"), -->
<!--       ) %>% -->
<!--       dplyr::filter(issue == "outlier (log distribution)") %>% -->
<!--       dplyr::select(dplyr::all_of(cols_to_add_cleaning_log), issue, dplyr::all_of(x)) %>% -->
<!--       tidyr::pivot_longer(cols = paste0(x), names_to = "question", values_to = "old_value") -->
<!--   } -->

<!--   outliers_cl <- do.call(rbind, outlier_checks) -->

<!--   outliers_cl <- outliers_cl %>% dplyr::distinct(!!!rlang::syms(cols_to_add_cleaning_log), question, old_value, .keep_all = T) -->


<!--   potential_outliers <- outliers_cl %>% dplyr::filter(!question %in% columns_not_to_check) -->


<!--   ## Append the list -->
<!--   if (is.data.frame(dataframe)) { -->
<!--     checked_dataset <- dataframe -->
<!--     return(list( -->
<!--       checked_dataset = checked_dataset, -->
<!--       potential_outliers = potential_outliers -->
<!--     )) -->
<!--   } -->

<!--   if (!is.data.frame(dataframe)) { -->
<!--     list_Df <- list(potential_outliers = potential_outliers) -->

<!--     return(append(dataframe, list_Df)) -->
<!--   } -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-check_outliers} -->

<!-- dataset_outlier <- data.frame( -->
<!--   uuid = paste0("uuid_", 1:100), -->
<!--   one_value = c(round(runif(90, min = 45, max = 55)),  -->
<!--                 round(runif(5)), round(runif(5, 99, 100))), -->
<!--   expense = c(sample(200:500,  -->
<!--                      replace = TRUE, size = 95),  -->
<!--               c(600, 100, 80, 1020, 1050)), -->
<!--   income = c(c(60, 0, 80, 1020, 1050),  -->
<!--              sample(20000:50000,  -->
<!--                     replace = TRUE, size = 95)), -->
<!--   yy = c(rep(100, 99), 10) -->
<!-- ) -->

<!-- check_outliers(dataset = dataset_outlier, -->
<!--                uuid_column = "uuid") |> -->
<!--   knitr::kable() -->
<!-- ``` -->

<!-- ```{r tests-check_outliers} -->
<!-- test_that("check_outliers works", { -->
<!--   expect_true(inherits(check_outliers, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## check_percentage_missing -->

<!-- ```{r function-check_percentage_missing} -->
<!-- #' Check the percentages of missing value -->
<!-- #' -->
<!-- #' The function will flag if a survey for its missing values. The missing values column can be created -->
<!-- #' with add_percentage_missing and the values are flagged with check_outliers. -->
<!-- #' -->
<!-- #' @param dataset a dataset to be check as a dataframe or a list with the -->
<!-- #' dataframe stored as "checked_dataset". -->
<!-- #' @param uuid_column uuid column in the dataset. Default is "uuid". -->
<!-- #' @param column_to_check string character with the name of the columns to check. Default is -->
<!-- #' "percentage_missing" -->
<!-- #' @param log_name name of the log of flagged value, default is percentage_missing_log -->
<!-- #' @param strongness_factor Strongness factor define how strong your outliers will be. The default is 3. -->
<!-- #' @return return a list with the dataset checked stored as checked_dataset and -->
<!-- #' a dataframe with the flagged values log -->
<!-- #' @export -->
<!-- #' -->
<!-- #' @seealso [cleaningtools::add_percentage_missing()], [cleaningtools::check_outliers()] -->

<!-- check_percentage_missing <- function(dataset, -->
<!--                                      uuid_column = "uuid", -->
<!--                                      column_to_check = "percentage_missing", -->
<!--                                      strongness_factor = 2, -->
<!--                                      log_name = "percentage_missing_log") { -->
<!--   if (is.data.frame(dataset)) { -->
<!--     dataset <- list(checked_dataset = dataset) -->
<!--   } -->
<!--   if (!("checked_dataset" %in% names(dataset))) { -->
<!--     stop("Cannot identify the dataset in the list") -->
<!--   } -->

<!--   if (!(uuid_column %in% names(dataset[["checked_dataset"]]))) { -->
<!--     msg <- glue::glue("Cannot find ", uuid_column, " in the names of the dataset") -->
<!--     stop(msg) -->
<!--   } -->

<!--   if (!(column_to_check %in% names(dataset[["checked_dataset"]]))) { -->
<!--     msg <- glue::glue("Cannot find ", column_to_check, " in the names of the dataset") -->
<!--     stop(msg) -->
<!--   } -->

<!--   log <- dataset[["checked_dataset"]] %>% -->
<!--     dplyr::select(dplyr::all_of(c(uuid_column, column_to_check))) %>% -->
<!--     check_outliers(uuid_column = uuid_column, strongness_factor = strongness_factor) -->

<!--   log[["potential_outliers"]] <- log[["potential_outliers"]] %>% -->
<!--     dplyr::mutate(dplyr::across(.cols = dplyr::everything(), .fns = as.character), -->
<!--       issue = "Percentages of missing values from this survey is different from others" -->
<!--     ) -->

<!--   dataset[[log_name]] <- log[["potential_outliers"]] -->

<!--   return(dataset) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-check_percentage_missing} -->

<!-- # Adding the percentage missing first -->
<!-- data_example <- data.frame( -->
<!--   uuid = letters[1:3], -->
<!--   col_1 = c(1:3), -->
<!--   col_2 = c(NA, NA, "expenditures"), -->
<!--   col_3 = c("with need", NA, "with need"), -->
<!--   col_4 = c("food health school", NA, "food"), -->
<!--   col_4.food = c(1, NA, 1), -->
<!--   col_4.health = c(1, NA, 0), -->
<!--   col_4.school = c(1, NA, 0) -->
<!-- ) -->

<!-- data_example <- data_example %>% -->
<!--     add_percentage_missing() -->

<!-- data_example %>%  -->
<!--   check_percentage_missing() |> -->
<!--   knitr::kable() -->


<!-- # With a dataset that already has a percentage missing -->
<!-- data_example2 <- data.frame( -->
<!--   uuid = letters, -->
<!--   any_cols = LETTERS, -->
<!--   any_number = 1:26, -->
<!--   percentage_missing = c(rep(.05, 25), .99) -->
<!-- ) -->

<!-- data_example2 %>%  -->
<!--   check_percentage_missing() |> -->
<!--   knitr::kable() -->
<!-- ``` -->

<!-- ```{r tests-check_percentage_missing} -->
<!-- test_that("check_percentage_missing works", { -->
<!--   expect_true(inherits(check_percentage_missing, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## check_pii -->

<!-- ```{r function-check_pii} -->
<!-- #' Checks for potential PII -->
<!-- #' @param dataset dataset to be check as a dataframe or a list with the dataframe stored as "checked_dataset" -->
<!-- #' @param uuid_column  uuid column in the dataset. Default is uuid. -->
<!-- #' @param element_name If the input is a list file, please specify the element name that contains the dataset -->
<!-- #' @param words_to_look Specify the words that might be the PIIs -->
<!-- #' @return dataset with potential PII -->
<!-- #' @export -->

<!-- check_pii <- function(dataset, -->
<!--                       element_name = "checked_dataset", -->
<!--                       uuid_column = "uuid", -->
<!--                       words_to_look = NULL) { -->
<!--   inputed_element <- dataset -->

<!--   if (!is.data.frame(dataset) & is.list(dataset)) { -->
<!--     if (!element_name %in% names(dataset)) { -->
<!--       stop("element_name not found") -->
<!--     } -->
<!--   } -->

<!--   if (!is.data.frame(dataset) & is.list(dataset)) { -->
<!--     dataset <- dataset[[element_name]] -->
<!--   } -->


<!--   if (uuid_column %in% names(dataset) == FALSE) { -->
<!--     stop("uuid not found in the dataset") -->
<!--   } -->


<!--   cols_to_look_for <- c( -->
<!--     "telephone", "contact", "name", "gps", "neighbourhood", "latitude", "longitude", "phone", -->
<!--     "contact number", "geo location", "geo", -->
<!--     "contact", "nom", "gps", "voisinage" -->
<!--   ) -->

<!--   cols_to_look_for <- c(words_to_look, cols_to_look_for) %>% snakecase::to_snake_case() -->
<!--   cols_to_look_for <- paste0(cols_to_look_for, collapse = "|") -->

<!--   select_multiple_to_ignore <- auto_sm_parent_children(dataset) -->
<!--   ignore <- c(select_multiple_to_ignore$sm_child, select_multiple_to_ignore$sm_parent) %>% unique() -->

<!--   potential_PII <- tibble::tibble( -->
<!--     uuid = "all", -->
<!--     question = names(dataset) -->
<!--   ) %>% -->
<!--     dplyr::filter(!question %in% ignore) %>% -->
<!--     dplyr::mutate( -->
<!--       snkae_case_cols = snakecase::to_snake_case(question) -->
<!--     ) %>% -->
<!--     dplyr::filter((grepl(cols_to_look_for, snkae_case_cols)) | (grepl(cols_to_look_for, question))) %>% -->
<!--     dplyr::mutate( -->
<!--       issue = "Potential PII" -->
<!--     ) %>% -->
<!--     dplyr::select(-snkae_case_cols) -->
<!--   ## Append the list -->
<!--   if (is.data.frame(inputed_element)) { -->
<!--     checked_dataset <- dataset -->
<!--     return(list( -->
<!--       checked_dataset = checked_dataset, -->
<!--       potential_PII = potential_PII -->
<!--     )) -->
<!--   } -->

<!--   if (!is.data.frame(inputed_element)) { -->
<!--     list_Df <- list(potential_PII = potential_PII) -->

<!--     return(append(inputed_element, list_Df)) -->
<!--   } -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-check_pii} -->

<!-- check_pii(cleaningtools_raw_data, uuid_column = "X_uuid") |> -->
<!--   knitr::kable() -->

<!-- ``` -->

<!-- ```{r tests-check_pii} -->
<!-- test_that("check_pii works", { -->
<!--   expect_true(inherits(check_pii, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## check_soft_duplicates -->

<!-- ```{r function-check_soft_duplicates} -->
<!-- #' Checks for survey similarities - Soft Duplicates -->
<!-- #' -->
<!-- #' @param dataset dataset to be check as a dataframe or a list with the dataframe stored as "checked_dataset" -->
<!-- #'  stored as "checked_dataset" -->
<!-- #' @param kobo_survey Kobo survey sheet. -->
<!-- #' @param uuid_column uuid column in the dataset. Default is "uuid". -->
<!-- #' @param idnk_value String character for the value of the "I don't know" value -->
<!-- #' @param sm_separator Separator for choice multiple questions. The default is "." -->
<!-- #' @param log_name Name of the log dataframe flagged in the end of the function -->
<!-- #' @param threshold flag all entries less or equal a specified threshold. The default is 7. -->
<!-- #' @param return_all_results By default, the function will return only the values that are under the -->
<!-- #' threshold. Default is FALSE. -->
<!-- #' -->
<!-- #' @return return a list with the dataset checked stored as checked_dataset and -->
<!-- #' a dataframe with the soft duplicate log -->
<!-- #' @export -->

<!-- check_soft_duplicates <- function(dataset, -->
<!--                                   kobo_survey, -->
<!--                                   uuid_column = "uuid", -->
<!--                                   idnk_value = "idnk", -->
<!--                                   sm_separator = ".", -->
<!--                                   log_name = "soft_duplicate_log", -->
<!--                                   threshold = 7, -->
<!--                                   return_all_results = FALSE) { -->
<!--   if (is.data.frame(dataset)) { -->
<!--     dataset <- list(checked_dataset = dataset) -->
<!--   } -->

<!--   if (!"checked_dataset" %in% names(dataset)) { -->
<!--     stop("Cannot identify the dataset in the list.") -->
<!--   } -->

<!--   if (!uuid_column %in% names(dataset[["checked_dataset"]])) { -->
<!--     msg <- glue::glue("Cannot find ", uuid_column, " in the names of the dataset") -->
<!--     stop(msg) -->
<!--   } -->

<!--   df <- dataset$checked_dataset -->
<!--   # 1) store UUIDs -->
<!--   uuids <- df[[uuid_column]] -->

<!--   # 2) convert all columns to character and tolower -->
<!--   df <- dplyr::mutate_all(df, as.character) -->
<!--   df <- dplyr::mutate_all(df, tolower) -->

<!--   # 3) remove columns that are naturally different in each survey: -->
<!--   # - columns of type = "start", "end", etc. -->
<!--   # - columns starting with "X_" -->
<!--   # - option columns for the select multiple -> keeping only the concatenation column -->
<!--   # - columns starting with special characters -->
<!--   types_to_remove <- c( -->
<!--     "start", "end", "today", "deviceid", "date", "geopoint", "audit", -->
<!--     "note", "calculate", "begin_group", "end_group" -->
<!--   ) -->
<!--   sm_parents <- auto_detect_sm_parents(df, sm_separator) -->
<!--   sm_columns <- df %>% -->
<!--     dplyr::select(dplyr::starts_with(glue::glue("{sm_parents}{sm_separator}"))) %>% -->
<!--     colnames() -->
<!--   cols_to_keep <- data.frame(column = colnames(df)) %>% -->
<!--     dplyr::left_join(dplyr::select(kobo_survey, name, type), by = c("column" = "name")) %>% -->
<!--     dplyr::filter(!is.na(type)) %>% -->
<!--     dplyr::filter((!(type %in% types_to_remove) & !stringr::str_starts(column, "X_") & -->
<!--       !(stringr::str_starts(column, "[[:punct:]]")) & !(column %in% sm_columns))) -->
<!--   df <- df[, cols_to_keep$column] -->

<!--   # 4) remove columns with all NA; convert remaining NA to "NA"; convert all columns to factor -->
<!--   df <- df[, colSums(is.na(df)) < nrow(df)] -->
<!--   df[is.na(df)] <- "NA" -->
<!--   df <- df %>% dplyr::mutate_if(is.character, factor) -->
<!--   error.message <- "NAs detected, remove them before proceeding (it can happen when converting to factor)" -->
<!--   if (sum(is.na(df)) > 0) stop(error.message) -->

<!--   # 5) calculate gower distance -->
<!--   gower_dist <- cluster::daisy(df, metric = "gower", warnBin = F, warnAsym = F, warnConst = F) -->
<!--   gower_mat <- as.matrix(gower_dist) -->

<!--   # 6) convert distance to number of differences and determine closest matching survey -->
<!--   r <- unlist(lapply(1:nrow(df), function(i) { -->
<!--     srv1 <- sort(gower_mat[i, ] * ncol(df))[2] -->
<!--     return(srv1) -->
<!--   })) -->

<!--   # 7) add relevant columns -->
<!--   outdata <- dataset$checked_dataset[, uuid_column] -->
<!--   outdata[["num_cols_not_NA"]] <- rowSums(df != "NA") -->
<!--   outdata[["total_columns_compared"]] <- ncol(df) -->
<!--   outdata[[paste0("num_cols_", idnk_value)]] <- rowSums(df == idnk_value) -->
<!--   outdata[["id_most_similar_survey"]] <- uuids[as.numeric(names(r))] -->
<!--   outdata[["number_different_columns"]] <- as.numeric(r) -->
<!--   outdata[["issue"]][outdata[["number_different_columns"]] <= threshold] <- glue::glue("Less than ", threshold, " differents options") -->
<!--   outdata <- outdata %>% -->
<!--     dplyr::arrange(number_different_columns, !!rlang::sym(uuid_column)) -->

<!--   names(outdata)[names(outdata) == uuid_column] <- "uuid" -->

<!--   if (!return_all_results) { -->
<!--     outdata <- outdata %>% -->
<!--       dplyr::filter(!is.na(issue)) -->
<!--   } -->

<!--   if(nrow(outdata) == 0) { -->
<!--     outdata <- outdata %>% -->
<!--       dplyr::select(uuid, issue) -->
<!--   } -->

<!--   dataset[[log_name]] <- as.data.frame(outdata) -->
<!--   return(dataset) -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-check_soft_duplicates} -->

<!-- soft_duplicates <- check_soft_duplicates( -->
<!--   dataset = cleaningtools_raw_data, -->
<!--   kobo_survey = cleaningtools_survey, -->
<!--   uuid_column = "X_uuid", -->
<!--   idnk_value = "dont_know", -->
<!--   sm_separator = ".", -->
<!--   log_name = "soft_duplicate_log", -->
<!--   threshold = 7 -->
<!-- ) -->


<!-- group_by_enum_raw_data <- cleaningtools_raw_data |> -->
<!--   dplyr::group_by(enumerator_num) -->


<!-- soft_per_enum <- group_by_enum_raw_data %>% -->
<!--   dplyr::group_split() %>% -->
<!--   purrr::map(~ check_soft_duplicates( -->
<!--     dataset = ., -->
<!--     kobo_survey = cleaningtools_survey, -->
<!--     uuid_column = "X_uuid", idnk_value = "dont_know", -->
<!--     sm_separator = ".", -->
<!--     log_name = "soft_duplicate_log", -->
<!--     threshold = 7, -->
<!--     return_all_results = TRUE -->
<!--   )) -->

<!-- soft_per_enum %>% -->
<!--   purrr::map(~ .[["soft_duplicate_log"]]) %>% -->
<!--   purrr::map2( -->
<!--     .y = dplyr::group_keys(group_by_enum_raw_data) %>% unlist(), -->
<!--     ~ dplyr::mutate(.x, enum = .y) -->
<!--   ) %>% -->
<!--   do.call(dplyr::bind_rows, .)  |> -->
<!--   knitr::kable() -->
<!-- ``` -->

<!-- ```{r tests-check_soft_duplicates} -->
<!-- test_that("check_soft_duplicates works", { -->
<!--   expect_true(inherits(check_soft_duplicates, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## check_value -->

<!-- ```{r function-check_value} -->
<!-- #' -->
<!-- #' Check for value(s) in the dataset -->
<!-- #' -->
<!-- #' @param dataset dataset to be check as a dataframe or a list with the dataframe stored as "checked_dataset" -->
<!-- #' @param uuid_column uuid column in the dataset. Default is "uuid". -->
<!-- #' @param element_name Name of the dataset in list -->
<!-- #' @param values_to_look Values to look. Default are- 99,999,999,88,888,888 -->
<!-- #' @return A dataframe as cleaning log format -->
<!-- #' @export -->

<!-- check_value <- function(dataset, -->
<!--                         uuid_column = "uuid", -->
<!--                         element_name = "checked_dataset", -->
<!--                         values_to_look = c(99, 999, 999, 88, 888, 888)) { -->
<!--   values_to_look <- values_to_look |> as.character() -->


<!--   ######### checking input -->

<!--   if (!is.list(dataset)) { -->
<!--     stop("Input must be a dataframe or list.") -->
<!--   } -->

<!--   checked_dataset <- dataset -->

<!--   if (!is.data.frame(dataset) & is.list(dataset)) { -->
<!--     if (is.null(element_name)) { -->
<!--       stop("element_name is missing") -->
<!--     } -->
<!--     if (!element_name %in% names(dataset)) { -->
<!--       stop("element_name not found") -->
<!--     } -->
<!--   } -->

<!--   if (!is.data.frame(dataset) & is.list(dataset)) { -->
<!--     dataset <- dataset[[element_name]] -->
<!--   } -->

<!--   ####################### -->


<!--   dataset <- dataset |> dplyr::rename(uuid = !!rlang::sym(uuid_column)) -->
<!--   dataset <- dataset |> dplyr::mutate_all(as.character) -->

<!--   dataset_only_na <- dataset |> dplyr::filter_all(dplyr::any_vars(. %in% values_to_look)) -->

<!--   flaged_value <- dataset_only_na |> -->
<!--     tidyr::pivot_longer(cols = !uuid) |> -->
<!--     dplyr::filter(value %in% values_to_look) |> -->
<!--     dplyr::rename( -->
<!--       question = name, -->
<!--       old_value = value -->
<!--     ) |> -->
<!--     dplyr::mutate(issue = "Possible value to be changed to NA") -->

<!--   ## create output -->
<!--   if (is.data.frame(checked_dataset)) { -->
<!--     return(list( -->
<!--       checked_dataset = checked_dataset, -->
<!--       flaged_value = flaged_value -->
<!--     )) -->
<!--   } -->

<!--   if (!is.data.frame(checked_dataset)) { -->
<!--     list_dataset <- list(flaged_value = flaged_value) -->

<!--     return(append(checked_dataset, list_dataset)) -->
<!--   } -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-check_value} -->

<!-- df <- data.frame( -->
<!--   X_uuid = paste0("uuid_", 1:100), -->
<!--   age = c(sample(18:80, replace = TRUE, size = 96), 99, 99, 98, 88), -->
<!--   gender = c("99", sample(c("male", "female"), -->
<!--     replace = TRUE, size = 95 -->
<!--   ), "98", "98", "88", "888") -->
<!-- ) -->


<!-- check_value(  dataset = df, uuid_column = "X_uuid", -->
<!--               element_name = "checked_dataset", -->
<!--               values_to_look = c(99, 98, 88, 888))  |> -->
<!--   knitr::kable() -->

<!-- ``` -->

<!-- ```{r tests-check_value} -->
<!-- test_that("check_value works", { -->
<!--   expect_true(inherits(check_value, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- # CREATE functions -->

<!-- ## create_audit_list -->

<!-- ```{r function-create_audit_list} -->
<!-- #' Read all audit files from a zip -->
<!-- #' -->
<!-- #' @param audit_zip_path location to .zip file. It must contain .zip -->
<!-- #' @param dataset dataset to (optional) -->
<!-- #' @param uuid_column uuid column if a dataset is provided. It will only read the uuid -->
<!-- #' present in the dataset. It will only be used if a dataset is provided. -->
<!-- #' -->
<!-- #' @return A list with all the audits file read as they are. -->
<!-- #' @export -->

<!-- create_audit_list <- function(audit_zip_path, -->
<!--                               dataset = NULL, -->
<!--                               uuid_column = "uuid") { -->
<!--   list_of_files <- utils::unzip(audit_zip_path, list = TRUE) %>% -->
<!--     dplyr::rename(path = Name) %>% -->
<!--     dplyr::filter(stringr::str_detect(path, pattern = "audit.csv")) -->

<!--   locatation_audit <- list_of_files %>% -->
<!--     dplyr::pull(path) %>% -->
<!--     stringr::str_split("/") %>% -->
<!--     purrr::set_names(list_of_files$path) %>% -->
<!--     purrr::map_dbl(~ which(stringr::str_detect(.x, "audit.csv"))) %>% -->
<!--     unique() -->

<!--   if (length(locatation_audit) != 1) { -->
<!--     stop("Please check the audit zip, some folders are not following the same structure.") -->
<!--   } -->

<!--   all_uuid_df <- list_of_files %>% -->
<!--     dplyr::select(path) %>% -->
<!--     dplyr::rowwise() %>% -->
<!--     dplyr::mutate(uuid = unlist(stringr::str_split(path, "/"))[[locatation_audit - 1]]) %>% -->
<!--     dplyr::ungroup() -->

<!--   if (!is.null(dataset)) { -->
<!--     if (uuid_column %in% names(dataset) != 1) { -->
<!--       msg <- glue::glue("The variable ", uuid_column, " cannot be identified in the dataset provided.") -->
<!--       stop(msg) -->
<!--     } -->
<!--     look_up_vector <- dataset[[uuid_column]] -->

<!--     if (any(!all_uuid_df$uuid %in% look_up_vector)) { -->
<!--       msg <- glue::glue(nrow(all_uuid_df) - length(look_up_vector), " audit files are found but not in the dataset. They won't be read.") -->
<!--       warning(msg) -->
<!--     } -->

<!--     all_uuid_df <- all_uuid_df %>% -->
<!--       dplyr::filter(uuid %in% look_up_vector) -->
<!--   } -->

<!--   list_of_audits <- all_uuid_df$path %>% -->
<!--     purrr::map(~ read.table(unz(audit_zip_path, filename = .x), header = TRUE, quote = "\"", sep = ",")) %>% -->
<!--     purrr::set_names(all_uuid_df$uuid) -->

<!--   if (!is.null(dataset)) { -->
<!--     if (length(list_of_audits) < length(look_up_vector)) { -->
<!--       to_add_vector <- look_up_vector[!look_up_vector %in% names(list_of_audits)] -->
<!--       msg <- glue::glue(length(to_add_vector), " audit files were not found. They were added as empty dataframes.") -->
<!--       warning(msg) -->
<!--       to_add <- purrr::map(to_add_vector, function(xx) { -->
<!--         list_of_audits[[1]] %>% dplyr::filter(event == "IWANTANEMPTYAUDIT") -->
<!--       }) %>% -->
<!--         purrr::set_names(to_add_vector) -->

<!--       list_of_audits <- append(list_of_audits, to_add) -->
<!--     } -->
<!--   } -->

<!--   return(list_of_audits) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-create_audit_list} -->
<!-- # create_audit_list("audit_path.zip") -->
<!-- ``` -->

<!-- ```{r tests-create_audit_list} -->
<!-- test_that("create_audit_list works", { -->
<!--   expect_true(inherits(create_audit_list, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## create_duration_from_audit_with_start_end -->

<!-- ```{r function-create_duration_from_audit_with_start_end} -->
<!-- #' Calculate duration from audit between 2 questions -->
<!-- #' -->
<!-- #' The function will calculate time difference between the start of the -->
<!-- #' start_question and the end of the end_question. -->
<!-- #' -->
<!-- #' In case the node appear several time (if the value was changed or with a -->
<!-- #' select multiple) it will take the minimum for the start and the maximum for -->
<!-- #' the end. -->
<!-- #' -->
<!-- #' If a value is missing (skip logic or question not found), it will return -Inf -->
<!-- #' -->
<!-- #' @param audit_file a dataframe with a single audit file, -->
<!-- #' it needs start, end, node column -->
<!-- #' @param start_question character vector use for the starting question -->
<!-- #' @param end_question character vector use for the ending question -->
<!-- #' -->
<!-- #' @return A dataframe with the duration in ms and duration in minutes. -->
<!-- #' @export -->

<!-- create_duration_from_audit_with_start_end <- function(audit_file, start_question, end_question) { -->
<!--   df_start_subset <- audit_file[grepl(paste0("\\/(?:", start_question, ")$"), audit_file$node), ] -->
<!--   start_question_df <- df_start_subset %>% dplyr::select(start) -->
<!--   start_question_df <- min(start_question_df$start) -->

<!--   df_end_subset <- audit_file[grepl(paste0("\\/(?:", end_question, ")$"), audit_file$node), ] -->
<!--   end_question_df <- df_end_subset %>% dplyr::select(end) -->
<!--   end_question_df <- max(end_question_df$end) -->

<!--   duration_ms <- end_question_df - start_question_df -->
<!--   duration_minutes <- round(duration_ms / 1000 / 60, 1) -->

<!--   data.frame( -->
<!--     duration_ms = duration_ms, -->
<!--     duration_minutes = duration_minutes -->
<!--   ) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-create_duration_from_audit_with_start_end} -->

<!-- some_audit <- data.frame( -->
<!--   event = c("form start", rep("question", 5)), -->
<!--   node = c("", paste0("/xx/question", 1:5)), -->
<!--   start = c( -->
<!--     1661415887295, 1661415887301, 1661415890819, -->
<!--     1661415892297, 1661415893529, 1661415894720 -->
<!--   ), -->
<!--   end = c( -->
<!--     NA, 1661415890790, 1661415892273, -->
<!--     1661415893506, 1661415894703, 1661415896452 -->
<!--   ) -->
<!-- ) -->


<!-- create_duration_from_audit_with_start_end(some_audit, -->
<!--                                           "question1",  -->
<!--                                           "question3") |> -->
<!--   knitr::kable()   -->
<!-- ``` -->

<!-- ```{r tests-create_duration_from_audit_with_start_end} -->
<!-- test_that("create_duration_from_audit_with_start_end works", { -->
<!--   expect_true(inherits(create_duration_from_audit_with_start_end, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## create_duration_from_audit_sum_all -->

<!-- ```{r function-create_duration_from_audit_sum_all} -->
<!-- #' Calculate duration from audit summing all time -->
<!-- #' -->
<!-- #' Duration is the difference between the sum of all start and the sum of all end. -->
<!-- #' It ignores all node that are empty such as form_start, end screen, form save, etc. -->
<!-- #' -->
<!-- #' @param audit_file a dataframe with a single audit file, -->
<!-- #' it needs start, end, node column -->
<!-- #' -->
<!-- #' @return A dataframe with the duration in ms and duration in minutes. -->
<!-- #' @export -->

<!-- create_duration_from_audit_sum_all <- function(audit_file) { -->
<!--   audit_file <- audit_file %>% dplyr::filter(node != "") -->
<!--   duration_ms <- sum(audit_file$end - audit_file$start) -->
<!--   duration_minutes <- round(duration_ms / 1000 / 60, 1) -->
<!--   data.frame( -->
<!--     duration_ms = duration_ms, -->
<!--     duration_minutes = duration_minutes -->
<!--   ) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-create_duration_from_audit_sum_all} -->

<!-- some_audit <- data.frame( -->
<!--   event = c("form start", rep("question", 5)), -->
<!--   node = c("", paste0("/xx/question", 1:5)), -->
<!--   start = c( -->
<!--     1661415887295, 1661415887301, 1661415890819, -->
<!--     1661415892297, 1661415893529, 1661415894720 -->
<!--   ), -->
<!--   end = c( -->
<!--     NA, 1661415890790, 1661415892273, -->
<!--     1661415893506, 1661415894703, 1661415896452 -->
<!--   ) -->
<!-- ) -->

<!-- create_duration_from_audit_sum_all(some_audit)|> -->
<!--   knitr::kable()   -->
<!-- ``` -->

<!-- ```{r tests-create_duration_from_audit_sum_all} -->
<!-- test_that("create_duration_from_audit_sum_all works", { -->
<!--   expect_true(inherits(create_duration_from_audit_sum_all, "function"))  -->
<!-- }) -->
<!-- ``` -->


<!-- ## create_combined_log -->

<!-- ```{r function-create_combined_log} -->
<!-- #' Merging the cleaning logs -->
<!-- #' -->
<!-- #' @param list_of_log A list file containig all the logs -->
<!-- #' @param dataset_name The dataset's name, if it exists in the list_of_log -->
<!-- #' -->
<!-- #' @return Combined cleaning log -->
<!-- #' @export -->

<!-- create_combined_log <- function(list_of_log, -->
<!--                                 dataset_name = "checked_dataset") { -->
<!--   ## log must be a list -->

<!--   if (is.data.frame(list_of_log) | is.character(list_of_log)) { -->
<!--     stop(glue::glue("list_of_log must be a list which should contain the logs.")) -->
<!--   } -->

<!--   ## look for dataset name -->
<!--   if (!is.null(dataset_name)) { -->
<!--     if (!dataset_name %in% names(list_of_log)) { -->
<!--       stop(glue::glue(dataset_name, " can not be found in the list_of_log.")) -->
<!--     } -->
<!--   } -->

<!--   if (is.null(dataset_name) & "checked_dataset" %in% names(list_of_log)) { -->
<!--     warning(glue::glue("You have a checked_dataset element in the list_of_log even though you have set dataset_name to NULL. Please check the parameter.")) -->
<!--   } -->

<!--   if (is.null(dataset_name) & !"checked_dataset" %in% names(list_of_log)) { -->
<!--     message(glue::glue("No dataset name is provided. Assuming that the dataset does not exist in the list_of_log.")) -->
<!--   } -->



<!--   output <- list() -->

<!--   if (!is.null(dataset_name)) { -->
<!--     output[["checked_dataset"]] <- list_of_log[[dataset_name]] -->
<!--   } -->

<!--   list_of_log_only <- list_of_log[names(list_of_log)[!names(list_of_log) %in% dataset_name]] -->


<!--   list_of_log_only <- list_of_log_only %>% -->
<!--     purrr::map(.f = ~ dplyr::mutate(., dplyr::across( -->
<!--       .cols = tidyselect::everything(), -->
<!--       .fns = ~ format(., scientific = F, justify = "none", trim = T) -->
<!--     ))) -->

<!--   print(names(list_of_log) |> glue::glue_collapse(", ") %>% glue::glue("List of element to combine- ", .)) -->

<!--   output[["cleaning_log"]] <- dplyr::bind_rows(list_of_log_only) |> -->
<!--     dplyr::mutate( -->
<!--       change_type = NA_character_, -->
<!--       new_value = NA_character_ -->
<!--       ) -->

<!--   if(is.null(output[["cleaning_log"]][["check_binding"]])) { -->
<!--     output[["cleaning_log"]] <- output[["cleaning_log"]] |> -->
<!--       dplyr::mutate( -->
<!--         check_binding = paste(question, uuid, sep = " ~/~ ") -->
<!--       ) -->
<!--   } else { -->
<!--     output[["cleaning_log"]] <- output[["cleaning_log"]] |> -->
<!--       dplyr::mutate( -->
<!--         check_binding = dplyr::case_when(is.na(check_binding) ~ paste(question, uuid, sep = " ~/~ "), -->
<!--                                          TRUE ~  check_binding) -->
<!--       ) -->

<!--   } -->

<!--   output -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-create_combined_log} -->
<!-- list <- cleaningtools::cleaningtools_raw_data |> -->
<!--   check_pii(uuid_column = "X_uuid") |> -->
<!--   check_duplicate(uuid_column = "X_uuid") |> -->
<!--   check_value(uuid_column = "X_uuid") -->

<!-- create_combined_log(list_of_log = list) -->

<!-- ``` -->

<!-- ```{r tests-create_combined_log} -->
<!-- test_that("create_combined_log works", { -->
<!--   expect_true(inherits(create_combined_log, "function"))  -->
<!-- }) -->
<!-- ``` -->


<!-- ## create_logic_for_other -->

<!-- ```{r function-create_logic_for_other} -->
<!-- #' Create logical checks for "other" values. -->
<!-- #' -->
<!-- #' @param kobo_survey Kobo survey sheet. -->
<!-- #' @param sm_separator Separator for choice multiple questions. The default is "." -->
<!-- #' @param compare_with_dataset Default FALSE will not compare the applicability of logics with the -->
<!-- #' dataset whereas TRUE will check the applicability of logics. -->
<!-- #' @param dataset dataset to be checked. -->
<!-- #' @return A dataframe will all logical tests to check "others" value. It should be used in -->
<!-- #' combination of review_others -->
<!-- #' @export -->

<!-- create_logic_for_other <- function(kobo_survey, -->
<!--                                    sm_separator = ".", -->
<!--                                    compare_with_dataset = FALSE, -->
<!--                                    dataset = NULL) { -->
<!--   my_bind_row <- get("bind_rows", asNamespace("dplyr")) -->



<!--   if (compare_with_dataset == T & is.null(dataset)) { -->
<!--     stop("Please provide the dataset") -->
<!--   } -->

<!--   list_of_logic <- list() -->


<!--   survey_join <- kobo_survey |> -->
<!--     dplyr::select(c("type", "name")) |> -->
<!--     dplyr::filter(grepl("select_one|select_multiple", type)) -->


<!--   kobo_tool_tidy <- kobo_survey |> -->
<!--     dplyr::filter(type == "text") |> -->
<!--     dplyr::filter(lengths(regmatches(relevant, gregexpr("\\$", relevant))) == 1) |> -->
<!--     dplyr::select(name, relevant) |> -->
<!--     dplyr::mutate( -->
<!--       parent = gsub(".*\\{(.+)\\}.*", "\\1", relevant), -->
<!--       other_choice = gsub(".*\\'(.+)\\'.*", "\\1", relevant) -->
<!--     ) |> -->
<!--     dplyr::left_join(survey_join, by = c("parent" = "name")) |> -->
<!--     dplyr::mutate(type = dplyr::case_when(grepl("_one", type) ~ "select_one", T ~ "select_multiple")) #|> -->

<!--   #### looking for name -->
<!--   if (compare_with_dataset == T) { -->
<!--     if (!all(unique(kobo_tool_tidy$parent) %in% names(dataset))) { -->
<!--       msg <- unique(kobo_tool_tidy$parent)[!unique(kobo_tool_tidy$parent) %in% names(dataset)] |> -->
<!--         glue::glue_collapse(", ") %>% -->
<!--         glue::glue("The following parent names: ", ., " were not found in the dataset. The function is ignoring them.") -->
<!--       warning(msg) -->
<!--     } -->
<!--     kobo_tool_tidy <- kobo_tool_tidy |> dplyr::filter(parent %in% names(dataset)) -->

<!--     if (!all(unique(kobo_tool_tidy$name) %in% names(dataset))) { -->
<!--       other_not_available_in_df <- unique(kobo_tool_tidy$name)[!unique(kobo_tool_tidy$name) %in% names(dataset)] -->
<!--       kobo_tool_tidy_not_available_df <- kobo_tool_tidy |> dplyr::filter(name %in% other_not_available_in_df) -->

<!--       list_of_logic[["kobo_tool_tidy_not_available_df_logic"]] <- kobo_tool_tidy_not_available_df |> -->
<!--         dplyr::mutate( -->
<!--           logic = dplyr::case_when( -->
<!--             type == "select_one" ~ -->
<!--               paste0(parent, " == \"", other_choice, "\""), -->
<!--             T ~ paste0( -->
<!--               "(`", parent, sm_separator, other_choice, "` == TRUE | `", -->
<!--               parent, sm_separator, other_choice, "` == 1 ) & !is.na(`", parent, sm_separator, other_choice, "`)" -->
<!--             ) -->
<!--           ) -->
<!--         ) |> -->
<!--         dplyr::mutate( -->
<!--           description = dplyr::case_when( -->
<!--             type == "select_one" ~ paste0(parent, " is selected but ", name, " is not found in the dataset"), -->
<!--             T ~ paste0(parent, sm_separator, other_choice, " is selected but ", name, " is not found in the dataset") -->
<!--           ), -->
<!--           variables_to_clean_column = dplyr::case_when( -->
<!--             type == "select_one" ~ paste0(parent), # ",",name), -->
<!--             T ~ paste0(parent, sm_separator, other_choice) # ,",",name)) -->
<!--           ), -->
<!--           associate_column_not_found = name -->
<!--         ) |> -->
<!--         dplyr::distinct() -->
<!--     } -->

<!--     kobo_tool_tidy <- kobo_tool_tidy |> dplyr::filter(name %in% names(dataset)) -->
<!--     ## parent must not_contain other -->

<!--     parent_must_not_contain_other <- kobo_tool_tidy -->
<!--   } -->

<!--   ####### select one ############### -->

<!--   kobo_select_one <- kobo_tool_tidy |> dplyr::filter(type == "select_one") -->


<!--   if (nrow(kobo_select_one) > 0) { -->
<!--     #### select one -->
<!--     list_of_logic[["select_one_is_not_na"]] <- kobo_select_one |> -->
<!--       dplyr::mutate( -->
<!--         logic = paste0( -->
<!--           "!is.na(", kobo_select_one$name, ") & (", kobo_select_one$parent, "!=", -->
<!--           "\"", kobo_select_one$other_choice, -->
<!--           "\"", ")" -->
<!--         ) -->
<!--       ) |> -->
<!--       dplyr::mutate( -->
<!--         description = paste0(name, " has value but the ", parent, " column is not ", other_choice, "(Not matching with kobo relevancy.)"), -->
<!--         variables_to_clean_column = paste0(parent, ",", name) -->
<!--       ) |> -->
<!--       dplyr::distinct() -->



<!--     ### not other but the _other has value -->

<!--     list_of_logic[["select_one_is_na"]] <- kobo_select_one |> -->
<!--       dplyr::mutate( -->
<!--         logic = paste0("is.na(", kobo_select_one$name, ") & (", kobo_select_one$parent, "==", "\"", kobo_select_one$other_choice, "\"", ")") -->
<!--       ) |> -->
<!--       dplyr::mutate( -->
<!--         description = paste0(name, " is NA but the ", parent, " column is seleted as other/relevent choice(", other_choice, ")"), -->
<!--         variables_to_clean_column = paste0(parent, ",", name) -->
<!--       ) |> -->
<!--       dplyr::distinct() -->
<!--   } -->


<!--   #### select multiple -->

<!--   kobo_select_multiple <- kobo_tool_tidy |> dplyr::filter(type == "select_multiple") -->

<!--   if (nrow(kobo_select_multiple) > 0) { -->
<!--     list_of_logic[["select_multiple_is_not_na"]] <- kobo_select_multiple |> -->
<!--       dplyr::mutate( -->
<!--         logic = paste0( -->
<!--           "!is.na(", name, ") & (`", parent, sm_separator, other_choice, "`==0 |`", -->
<!--           parent, sm_separator, other_choice, "`==FALSE | is.na(`", parent, sm_separator, other_choice, "`))" -->
<!--         ) -->
<!--       ) |> -->
<!--       dplyr::mutate( -->
<!--         description = paste0(name, " is NOT NA but the binary column ( ", parent, sm_separator, other_choice, ") is selected as FALSE/0/NA"), -->
<!--         variables_to_clean_column = paste0(name, ",", parent, sm_separator, other_choice) -->
<!--       ) |> -->
<!--       dplyr::distinct() -->



<!--     list_of_logic[["select_multiple_is_na"]] <- kobo_select_multiple |> -->
<!--       dplyr::mutate( -->
<!--         logic = paste0( -->
<!--           "is.na(", name, ") & (`", parent, sm_separator, other_choice, "`==1 |`", -->
<!--           parent, sm_separator, other_choice, "`== TRUE)" -->
<!--         ) -->
<!--       ) |> -->
<!--       dplyr::mutate( -->
<!--         description = paste0(name, " is NA but the binary column (", parent, sm_separator, other_choice, ")is selected as TRUE/1"), -->
<!--         variables_to_clean_column = paste0(name, ",", parent, sm_separator, other_choice) -->
<!--       ) |> -->
<!--       dplyr::distinct() -->
<!--   } -->

<!--   all_logic <- do.call("my_bind_row", list_of_logic) -->


<!--   all_logic |> -->
<!--     dplyr::mutate(id = paste("id-", dplyr::cur_group_rows())) |> -->
<!--     dplyr::select(id, logic, description, variables_to_clean_column) -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-create_logic_for_other} -->

<!-- create_logic_for_other( -->
<!--   kobo_survey = cleaningtools::cleaningtools_survey, -->
<!--   sm_separator = ".", -->
<!--   dataset = cleaningtools::cleaningtools_clean_data, -->
<!--   compare_with_dataset = TRUE -->
<!-- ) -->
<!-- ``` -->

<!-- ```{r tests-create_logic_for_other} -->
<!-- test_that("create_logic_for_other works", { -->
<!--   expect_true(inherits(create_logic_for_other, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## create_formated_wb -->

<!-- ```{r function-create_formated_wb} -->
<!-- #' Creates formatted workbook with openxlsx -->
<!-- #' -->
<!-- #' @param write_list List of dataframe -->
<!-- #' @param header_front_color Hexcode for header front color (default is white) -->
<!-- #' @param header_front_size Header front size (default is 12) -->
<!-- #' @param header_fill_color Hexcode for header fill color (default is red) -->
<!-- #' @param header_front Front name for header (default is Arial Narrow) -->
<!-- #' @param body_front Front name for body (default is Arial Narrow) -->
<!-- #' @param body_front_size Front size for body (default is 11) -->
<!-- #' @param column_for_color Column name in the dataframe which should be used for colorizing the cell. The default is null. -->
<!-- #' -->
<!-- #' @return A workbook -->
<!-- #' @export -->

<!-- create_formated_wb <- function(write_list, -->
<!--                                column_for_color = NULL, -->
<!--                                header_front_size = 12, -->
<!--                                header_front_color = "#FFFFFF", -->
<!--                                header_fill_color = "#ee5859", -->
<!--                                header_front = "Arial Narrow", -->
<!--                                body_front = "Arial Narrow", -->
<!--                                body_front_size = 11) { -->
<!--   headerStyle <- openxlsx::createStyle( -->
<!--     fontSize = header_front_size, -->
<!--     fontColour = header_front_color, -->
<!--     halign = "center", -->
<!--     valign = "center", -->
<!--     fontName = header_front, -->
<!--     textDecoration = "bold", -->
<!--     fgFill = header_fill_color, -->
<!--     border = "TopBottomLeftRight ", -->
<!--     borderColour = "#fafafa", -->
<!--     wrapText = T -->
<!--   ) -->

<!--   bodyStyle <- openxlsx::createStyle( -->
<!--     fontSize = body_front_size, -->
<!--     fontName = body_front, -->
<!--     border = "TopBottomLeftRight ", -->
<!--     borderColour = "#4F81BD", -->
<!--     valign = "center", -->
<!--     halign = "left" -->
<!--   ) -->

<!--   wb <- openxlsx::createWorkbook() -->

<!--   number_of_sheet <- length(write_list) -->

<!--   for (i in 1:number_of_sheet) { -->
<!--     dataset_name <- names(write_list[i]) -->
<!--     dataset <- write_list[[dataset_name]] |> as.data.frame() -->

<!--     openxlsx::addWorksheet(wb, dataset_name) -->
<!--     openxlsx::writeData(wb, sheet = i, dataset, rowNames = F) -->
<!--     openxlsx::addFilter(wb, sheet = i, row = 1, cols = 1:ncol(dataset)) -->
<!--     openxlsx::freezePane(wb, sheet = i, firstCol = TRUE, firstRow = T) -->
<!--     openxlsx::addStyle(wb, sheet = i, headerStyle, rows = 1, cols = 1:ncol(dataset), gridExpand = TRUE) -->
<!--     openxlsx::addStyle(wb, sheet = i, bodyStyle, rows = 1:nrow(dataset) + 1, cols = 1:ncol(dataset), gridExpand = TRUE) -->
<!--     openxlsx::setColWidths(wb, i, cols = 1:ncol(dataset), widths = 25) -->
<!--     openxlsx::setRowHeights(wb, i, 1, 20) -->

<!--     if (!is.null(column_for_color)) { -->
<!--       u <- unique(dataset[[column_for_color]]) -->

<!--       for (x in u) { -->
<!--         y <- which(dataset[[column_for_color]] == x) -->

<!--         random.color <- randomcoloR::randomColor(1, luminosity = "light") -->

<!--         style <- openxlsx::createStyle( -->
<!--           fgFill = random.color, -->
<!--           fontSize = body_front_size, -->
<!--           fontName = body_front, -->
<!--           border = "TopBottomLeftRight ", -->
<!--           borderColour = "#4F81BD", -->
<!--           valign = "center", -->
<!--           halign = "left" -->
<!--         ) -->


<!--         openxlsx::addStyle(wb, sheet = i, style, rows = y + 1, cols = 1:ncol(dataset), gridExpand = TRUE) -->
<!--       } -->
<!--     } -->
<!--   } -->

<!--   wb -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-create_formated_wb} -->

<!-- checks_list <- cleaningtools::cleaningtools_raw_data |> -->
<!--   check_pii(uuid_column = "X_uuid") |> -->
<!--   check_duplicate(uuid_column = "X_uuid") |> -->
<!--   check_value(uuid_column = "X_uuid")  -->

<!-- create_combined_log(list_of_log = checks_list) |> -->
<!--   create_formated_wb() -->
<!-- ``` -->

<!-- ```{r tests-create_formated_wb} -->
<!-- test_that("create_formated_wb works", { -->
<!--   expect_true(inherits(create_formated_wb, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## create_cleaning_log -->

<!-- ```{r function-create_cleaning_log} -->
<!-- #' Generates cleaning log -->
<!-- #' @param raw_dataset Raw dataset -->
<!-- #' @param raw_dataset_uuid_column uuid column in the raw dataset. Default is "uuid". -->
<!-- #' @param clean_dataset Clean dataset -->
<!-- #' @param clean_dataset_uuid_column uuid column in the raw dataset. Default is "uuid". -->
<!-- #' @param check_for_deletion_log TRUE to flag the removed survey -->
<!-- #' @param check_for_variable_name TRUE to flag the removed variables -->
<!-- #' @param  columns_not_to_check Columns to exclude from the checks -->
<!-- #' @return Cleaning log -->
<!-- #' @export -->

<!-- # generate cleaning log --------------------------------------------------- -->
<!-- create_cleaning_log <- function(raw_dataset, -->
<!--                                 raw_dataset_uuid_column = "uuid", -->
<!--                                 clean_dataset = clean_dataset, -->
<!--                                 clean_dataset_uuid_column = "uuid", -->
<!--                                 check_for_deletion_log = T, -->
<!--                                 columns_not_to_check = NULL, -->
<!--                                 check_for_variable_name = T) { -->

<!--   raw_dataset <- raw_dataset %>% -->
<!--     dplyr::mutate(dplyr::across( -->
<!--       .cols = tidyselect::everything(), -->
<!--       .fns = ~coerce_to_character(.x))) -->
<!--   clean_dataset <- clean_dataset %>% -->
<!--     dplyr::mutate(dplyr::across( -->
<!--       .cols = tidyselect::everything(), -->
<!--       .fns = ~coerce_to_character(.x))) -->
<!--   raw_dataset$uuid <- raw_dataset[[raw_dataset_uuid_column]] -->
<!--   clean_dataset$uuid <- clean_dataset[[clean_dataset_uuid_column]] -->

<!--   # log list -->
<!--   log <- list() -->



<!--   # create deletion log  --------------------------------------------------- -->
<!--   if (check_for_deletion_log == T & -->
<!--       !all(unique(raw_dataset[[raw_dataset_uuid_column]]) %in% clean_dataset[[clean_dataset_uuid_column]])) { -->
<!--     deleted_uuid <- -->
<!--       raw_dataset$uuid[!raw_dataset$uuid %in% clean_dataset$uuid] -->
<!--     log[["deletaion_log"]] <- data.frame(uuid = deleted_uuid, -->
<!--                                          change_type = "remove_survey", -->
<!--                                          comment = "No matching uuid in the cleaned dataset") -->
<!--   } -->

<!--   # create deletion log [number of clean data is grater than number of row data]  --------------------------------------------------- -->
<!--   if (check_for_deletion_log == T & -->
<!--       !all(unique(clean_dataset[[clean_dataset_uuid_column]]) %in% raw_dataset[[raw_dataset_uuid_column]])) { -->
<!--     deleted_uuid <- -->
<!--       clean_dataset$uuid[!clean_dataset$uuid %in% raw_dataset$uuid] -->
<!--     log[["added_survey"]] <- data.frame(uuid = deleted_uuid, -->
<!--                                         change_type = "added_survey", -->
<!--                                         comment = "Survey added to the clean dataset.") -->
<!--   } -->



<!--   # check variable name [removed from clean data] --------------------------- -->

<!--   if (check_for_variable_name == T) { -->
<!--     ## variable removed -->

<!--     removed_variable_name <- -->
<!--       names(raw_dataset)[!names(raw_dataset) %in% names(clean_dataset)] -->

<!--     if (length(removed_variable_name) > 0) { -->
<!--       log[["variable_removed"]] <- data.frame( -->
<!--         uuid = "all", -->
<!--         question = removed_variable_name, -->
<!--         change_type = "variable_removed", -->
<!--         comment = "variable removed from the clean dataset" -->
<!--       ) -->
<!--     } -->


<!--     ## variable added -->

<!--     added_variable_name <- -->
<!--       names(clean_dataset)[!names(clean_dataset) %in% names(raw_dataset)] -->

<!--     if (length(added_variable_name) > 0) { -->
<!--       log[["variable_added"]] <- data.frame( -->
<!--         uuid = "all", -->
<!--         question = added_variable_name, -->
<!--         change_type = "variable_added", -->
<!--         comment = "variable added to the clean dataset" -->
<!--       ) -->
<!--     } -->
<!--   } # end check for variable -->


<!--   # create log for change_response ------------------------------------------ -->

<!--   uuidlist <- -->
<!--     clean_dataset$uuid[clean_dataset$uuid %in% raw_dataset$uuid] -->

<!--   varlist <- -->
<!--     names(raw_dataset)[names(raw_dataset) %in% names(clean_dataset)] -->

<!--   varlist <- varlist[!varlist %in% unique( -->
<!--     c( -->
<!--       "uuid", -->
<!--       "start", -->
<!--       "end", -->
<!--       "X_index", -->
<!--       "_index", -->
<!--       "index", -->
<!--       "X_status", -->
<!--       "_status", -->
<!--       "status", -->
<!--       "today", -->
<!--       "X_submitted_by", -->
<!--       "_submitted_by", -->
<!--       "submitted_by", -->
<!--       "X_submission_time", -->
<!--       "_submission_time", -->
<!--       "submission_time", -->
<!--       raw_dataset_uuid_column, -->
<!--       columns_not_to_check -->
<!--     ) -->
<!--   )] -->


<!--   ############################# change_response ############################################ -->
<!--   log[["change_response"]] <- -->
<!--     lapply(varlist, function(x, clean_dataset, raw_dataset) { -->
<!--       check <- -->
<!--         merge(clean_dataset[c("uuid", x)], -->
<!--               raw_dataset[c("uuid", x)], -->
<!--               by = "uuid", -->
<!--               all.x = T) -->

<!--       index <- which(check[, 2] != check[, 3]) -->

<!--       if (length(index) != 0) { -->
<!--         check <- check[index,] -->
<!--         names(check) <- c("uuid", "new_value", "old_value") -->
<!--         check$question <- x -->
<!--         check$change_type <- "change_response" -->
<!--         check$comment <- "An alteration was performed" -->
<!--         return(check) -->
<!--       } -->
<!--       message(x) -->
<!--     }, clean_dataset = clean_dataset, raw_dataset = raw_dataset) %>% do.call(rbind, .) -->



<!--   ############################# NA_to_change_response ############################################ -->

<!--   log[["NA_to change_response"]] <- -->
<!--     lapply(varlist, function(x, clean_dataset, raw_dataset) { -->
<!--       check <- -->
<!--         merge(clean_dataset[c("uuid", x)], -->
<!--               raw_dataset[c("uuid", x)], -->
<!--               by = "uuid", -->
<!--               all.x = T) -->

<!--       index <- which(!is.na(check[, 2]) & is.na(check[, 3])) -->

<!--       if (length(index) != 0) { -->
<!--         check <- check[index,] -->
<!--         names(check) <- c("uuid", "new_value", "old_value") -->
<!--         check$question <- x -->
<!--         check$change_type <- "change_response" -->
<!--         check$comment <- "NA changed to value" -->
<!--         return(check) -->
<!--       } -->
<!--       message(x) -->
<!--     }, clean_dataset = clean_dataset, raw_dataset = raw_dataset) %>% do.call(rbind, .) -->

<!--   ############################# blank_response ############################################ -->
<!--   log[["blank_response"]] <- -->
<!--     lapply(varlist, function(x, clean_dataset, raw_dataset) { -->
<!--       check <- -->
<!--         merge(clean_dataset[c("uuid", x)], -->
<!--               raw_dataset[c("uuid", x)], -->
<!--               by = "uuid", -->
<!--               all.x = T) -->

<!--       index <- which(is.na(check[, 2]) & !is.na(check[, 3])) -->

<!--       if (length(index) != 0) { -->
<!--         check <- check[index,] -->
<!--         names(check) <- c("uuid", "new_value", "old_value") -->
<!--         check$question <- x -->
<!--         check$change_type <- "blank_response" -->
<!--         check$comment <- "changed to NA" -->
<!--         return(check) -->
<!--       } -->
<!--       message(x) -->
<!--     }, clean_dataset = clean_dataset, raw_dataset = raw_dataset) %>% do.call(rbind, .) -->

<!--   all_log <- do.call(dplyr::bind_rows, log) -->
<!--   if (nrow(all_log) > 0) { -->
<!--     all_log <- all_log |> dplyr::select(dplyr::any_of( -->
<!--       c( -->
<!--         "uuid", -->
<!--         "question", -->
<!--         "change_type", -->
<!--         "new_value", -->
<!--         "old_value", -->
<!--         "comment" -->
<!--       ) -->
<!--     )) -->
<!--   } -->

<!--   return(all_log) -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-create_cleaning_log} -->

<!-- log <- create_cleaning_log( raw_dataset = cleaningtools::cleaningtools_raw_data,  -->
<!--                             raw_dataset_uuid_column = "X_uuid", -->
<!--                             clean_dataset = cleaningtools::cleaningtools_clean_data,  -->
<!--                             clean_dataset_uuid_column = "X_uuid", -->
<!--                             check_for_deletion_log = TRUE,  -->
<!--                             check_for_variable_name = TRUE) -->

<!-- log |> knitr::kable() -->

<!-- ``` -->

<!-- ```{r tests-create_cleaning_log} -->
<!-- test_that("create_cleaning_log works", { -->
<!--   expect_true(inherits(create_cleaning_log, "function"))  -->
<!-- }) -->
<!-- ``` -->





<!-- ## create_xlsx_cleaning_log -->

<!-- ```{r function-create_xlsx_cleaning_log} -->
<!-- #' Creates formatted excel for cleaning log -->
<!-- #' -->
<!-- #' @param write_list List of dataframe -->
<!-- #' @param cleaning_log_name Name for cleaning log from write_list -->
<!-- #' @param change_type_col Change type column name in the cleaning log -->
<!-- #' @param header_front_color Hexcode for header front color (default is white) -->
<!-- #' @param header_front_size Header front size (default is 12) -->
<!-- #' @param header_fill_color Hexcode for header fill color (default is red) -->
<!-- #' @param header_front Front name for header (default is Arial Narrow) -->
<!-- #' @param body_front Front name for body (default is Arial Narrow) -->
<!-- #' @param body_front_size Front size for body (default is 11) -->
<!-- #' @param column_for_color Column name in the dataframe which should be used for colorizing the cell. The default is null. -->
<!-- #' @param use_dropdown Use drop down lists for data validation in the cleaning log output (default is FALSE) -->
<!-- #' @param sm_dropdown_type Dropdown list options for select multiple questions: numerical (1/0) or logical (TRUE/FALSE) - default is logical -->
<!-- #' @param kobo_survey Kobo survey dataframe -->
<!-- #' @param kobo_choices Kobo choices dataframe -->
<!-- #' @param output_path Output path. Default is NULL which will return a workbook instead of an excel file. -->
<!-- #' -->
<!-- #' @return save a .xlsx file or return a workbook object -->
<!-- #' @export -->
<!-- #' -->

<!-- create_xlsx_cleaning_log <- function(write_list, -->
<!--                                      cleaning_log_name = "cleaning_log", -->
<!--                                      change_type_col = "change_type", -->
<!--                                      column_for_color = "check_binding", -->
<!--                                      header_front_size = 12, -->
<!--                                      header_front_color = "#FFFFFF", -->
<!--                                      header_fill_color = "#ee5859", -->
<!--                                      header_front = "Arial Narrow", -->
<!--                                      body_front = "Arial Narrow", -->
<!--                                      body_front_size = 11, -->
<!--                                      use_dropdown = F, -->
<!--                                      sm_dropdown_type = NULL, -->
<!--                                      kobo_survey = NULL, -->
<!--                                      kobo_choices = NULL, -->
<!--                                      output_path = NULL) { -->
<!--   if (use_dropdown & (is.null(kobo_survey) | is.null(kobo_choices))) { -->
<!--     stop(glue::glue("Kobo survey and choices sheets should be provided to use dropdown lists")) -->
<!--   } -->
<!--   if (!is.null(kobo_survey) && !verify_valid_survey(kobo_survey)) { -->
<!--     stop(glue::glue("The Kobo survey dataframe is not valid")) -->
<!--   } -->
<!--   if (!is.null(kobo_choices) && !verify_valid_choices(kobo_choices)) { -->
<!--     stop(glue::glue("The Kobo choices dataframe is not valid")) -->
<!--   } -->
<!--   if (!is.null(sm_dropdown_type) && !stringr::str_to_lower(sm_dropdown_type) %in% c("logical", "numerical")) { -->
<!--     stop(glue::glue("Invalid value for sm_dropdown_type - only 'logical' and 'numerical' are accepted")) -->
<!--   } -->
<!--   if (!cleaning_log_name %in% names(write_list)) { -->
<!--     stop(glue::glue(cleaning_log_name, " not found in the given list.")) -->
<!--   } -->
<!--   if (!change_type_col %in% names(write_list[[cleaning_log_name]])) { -->
<!--     stop(glue::glue(change_type_col, " not found in ", cleaning_log_name, ".")) -->
<!--   } -->
<!--   if ("validation_rules" %in% names(write_list)) { -->
<!--     stop(glue::glue("The list currently has an element named `validation_rules`. Please consider renaming it.")) -->
<!--   } -->

<!--   tryCatch( -->
<!--     if (!is.null(kobo_survey) & !is.null(kobo_choices) & use_dropdown == TRUE) { -->
<!--       data.val <- create_validation_list(kobo_choices, kobo_survey |> dplyr::filter(!stringr::str_detect(pattern = "(begin|end)(\\s+|_)group", type))) -->
<!--     }, -->
<!--     error = function(e) { -->
<!--       warning("Validation list was not created") -->
<!--     } -->
<!--   ) -->

<!--   if (!is.null(kobo_survey) & !is.null(kobo_choices) & use_dropdown == TRUE & exists("data.val", inherits = FALSE)) { -->
<!--     write_list[["validation_rules"]] <- data.val -->
<!--   } else { -->
<!--     write_list[["validation_rules"]] <- data.frame( -->
<!--       change_type_validation = c("change_response", "blank_response", "remove_survey", "no_action") -->
<!--     ) -->
<!--   } -->



<!--   write_list[["readme"]] <- data.frame( -->
<!--     change_type_validation = c("change_response", "blank_response", "remove_survey", "no_action"), -->
<!--     description = c( -->
<!--       "Change the response to new.value", -->
<!--       "Remove and NA the response", -->
<!--       "Delete the survey", -->
<!--       "No action to take." -->
<!--     ) -->
<!--   ) -->

<!--   workbook <- write_list |> create_formated_wb( -->
<!--     column_for_color = column_for_color, -->
<!--     header_front_size = header_front_size, -->
<!--     header_front_color = header_front_color, -->
<!--     header_fill_color = header_fill_color, -->
<!--     header_front = header_front, -->
<!--     body_front = body_front, -->
<!--     body_front_size = body_front_size -->
<!--   ) -->


<!--   hide_sheet <- which(names(workbook) == "validation_rules") -->

<!--   openxlsx::sheetVisibility(workbook)[hide_sheet] <- F -->


<!--   row_numbers <- 2:(nrow(write_list[[cleaning_log_name]]) + 1) -->
<!--   col_number <- which(names(write_list[[cleaning_log_name]]) == change_type_col) -->


<!--   if (!is.null(kobo_survey) & !is.null(kobo_choices) & use_dropdown == TRUE & exists("data.val", inherits = FALSE)) { -->
<!--     cl <- write_list[[cleaning_log_name]] -->

<!--     for (r in 1:nrow(cl)) { -->
<!--       if (cl[r, "question"] %in% colnames(data.val) & as.character(cl[r, "uuid"]) != "all") { -->
<!--         openxlsx::dataValidation(workbook, -->
<!--           sheet = cleaning_log_name, cols = which(colnames(cl) == "new_value"), -->
<!--           rows = r + 1, type = "list", -->
<!--           value = create_col_range(as.character(cl[r, "question"]), data.val) -->
<!--         ) %>% -->
<!--           suppressWarnings() -->
<!--       } else if ((stringr::str_detect(string = as.character(cl[r, "question"]), pattern = "\\.") | -->
<!--         (stringr::str_detect(string = as.character(cl[r, "question"]), pattern = "\\/") & -->
<!--           (stringr::str_detect(string = as.character(cl[r, "question"]), pattern = "/") == 1))) & -->
<!--         as.character(cl[r, "uuid"]) != "all") { -->
<!--         if (is.null(sm_dropdown_type) || stringr::str_to_lower(sm_dropdown_type) == "logical") { -->
<!--           openxlsx::dataValidation(workbook, -->
<!--             sheet = cleaning_log_name, cols = which(colnames(cl) == "new_value"), -->
<!--             rows = r + 1, type = "list", -->
<!--             value = create_col_range("binaries_sm_options_lgl", data.val) -->
<!--           ) -->
<!--         } else { -->
<!--           openxlsx::dataValidation(workbook, -->
<!--             sheet = cleaning_log_name, cols = which(colnames(cl) == "new_value"), -->
<!--             rows = r + 1, type = "list", -->
<!--             value = create_col_range("binaries_sm_options_num", data.val) -->
<!--           ) -->
<!--         } -->
<!--       } -->
<!--     } -->

<!--     openxlsx::dataValidation(workbook, -->
<!--       sheet = cleaning_log_name, cols = col_number, -->
<!--       rows = row_numbers, type = "list", -->
<!--       value = create_col_range("change_type_validation", data.val) -->
<!--     ) %>% -->
<!--       suppressWarnings() -->
<!--   } else { -->
<!--     openxlsx::dataValidation(workbook, -->
<!--       sheet = cleaning_log_name, cols = col_number, -->
<!--       rows = row_numbers, type = "list", -->
<!--       value = "'validation_rules'!$A$2:$A$5" -->
<!--     ) %>% -->
<!--       suppressWarnings() -->
<!--   } -->

<!--   if (is.null(output_path)) { -->
<!--     return(workbook) -->
<!--   } -->

<!--   if (!is.null(output_path)) { -->
<!--     openxlsx::saveWorkbook(workbook, output_path, overwrite = TRUE) -->
<!--   } -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-create_xlsx_cleaning_log} -->

<!-- checks_list <- cleaningtools::cleaningtools_raw_data |> -->
<!--   check_pii(uuid_column = "X_uuid") |> -->
<!--   check_duplicate(uuid_column = "X_uuid") |> -->
<!--   check_value(uuid_column = "X_uuid") -->

<!-- create_combined_log(list_of_log = checks_list) |> -->
<!--   create_xlsx_cleaning_log() -->

<!-- logical_check_example <- cleaningtools::cleaningtools_raw_data |> -->
<!--   check_logical( -->
<!--     check_to_perform = 'treat_cook_water == "always_treat"', -->
<!--     uuid_column = "X_uuid", -->
<!--     description = "description", -->
<!--     check_id = "check_4", -->
<!--     columns_to_clean = "treat_cook_water"  ) -->

<!-- create_combined_log(logical_check_example) |> -->
<!--   create_xlsx_cleaning_log( -->
<!--     output_path = paste0(tempdir(check = TRUE), "/cleaning_log.xlsx"), -->
<!--     cleaning_log_name = "cleaning_log", -->
<!--     change_type_col = "change_type", -->
<!--     kobo_survey = cleaningtools::cleaningtools_survey, -->
<!--     kobo_choices = cleaningtools::cleaningtools_choices, -->
<!--     use_dropdown = TRUE, -->
<!--     sm_dropdown_type = "logical" -->
<!--   ) -->

<!-- ``` -->


<!-- ```{r tests-create_xlsx_cleaning_log} -->
<!-- test_that("create_xlsx_cleaning_log works", { -->
<!--   expect_true(inherits(create_xlsx_cleaning_log, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## create_clean_data -->

<!-- ```{r function-create_clean_data} -->
<!-- #' implement cleaning log on raw data set. -->
<!-- #' @param raw_dataset Raw dataset -->
<!-- #' @param raw_data_uuid_column uuid column in the raw dataset. Default is uuid. -->
<!-- #' @param cleaning_log cleaning + deletion log (data.frame). -->
<!-- #' @param cleaning_log_uuid_column uuid column in the cleaning log. Default is "uuid". -->
<!-- #' @param cleaning_log_question_column column in cleaning log which specifies data set column to change -->
<!-- #' @param cleaning_log_new_value_column cleaning log column specifying the new correct value -->
<!-- #' @param cleaning_log_change_type_column column in cleaning log which specifies change type to be made -->
<!-- #' @param change_response_value values in change type column which should be changed to a new value. -->
<!-- #' @param NA_response_value values in change type column which should be blank (NA). -->
<!-- #' @param no_change_value values in change type column which should NOT be changed to a new value. -->
<!-- #' @param remove_survey_value values in change type column which should be deleted from the data. -->
<!-- #' -->
<!-- #' @return clean data set -->
<!-- #' @export -->

<!-- create_clean_data <- function(raw_dataset, -->
<!--                               raw_data_uuid_column = "uuid", -->
<!--                               cleaning_log, -->
<!--                               cleaning_log_uuid_column = "uuid", -->
<!--                               cleaning_log_question_column, -->
<!--                               cleaning_log_new_value_column, -->
<!--                               cleaning_log_change_type_column, -->
<!--                               change_response_value = "change_response", -->
<!--                               NA_response_value = "blank_response", -->
<!--                               no_change_value = "no_action", -->
<!--                               remove_survey_value = "remove_survey") { -->
<!--   raw_dataset <- raw_dataset %>% dplyr::mutate_all(as.character) -->
<!--   cleaning_log <- cleaning_log %>% dplyr::mutate_all(as.character) -->



<!--   assertthat::assert_that(cleaning_log_change_type_column %in% names(cleaning_log), -->
<!--                           msg = "cleaning_log_change_type_column column not found in cleaning log") -->

<!--   all_type <- -->
<!--     c(change_response_value, -->
<!--       NA_response_value, -->
<!--       no_change_value, -->
<!--       remove_survey_value) -->

<!--   cleaning_log <- cleaning_log |> dplyr::mutate( -->
<!--     change_type_created_f = dplyr::case_when( -->
<!--       !!rlang::sym(cleaning_log_change_type_column) %in% change_response_value ~ "change_response", -->
<!--       !!rlang::sym(cleaning_log_change_type_column) %in% NA_response_value ~ "blank_response", -->
<!--       !!rlang::sym(cleaning_log_change_type_column) %in% no_change_value ~ "no_action", -->
<!--       !!rlang::sym(cleaning_log_change_type_column) %in% remove_survey_value ~ "remove_survey" -->
<!--     ) -->
<!--   ) -->

<!--   assertthat::assert_that(any(!is.na(cleaning_log[[cleaning_log_change_type_column]])), -->
<!--                           msg = "You have NAs in change_type option(s)") -->


<!--   check_not_entry_value_in_change_type <- -->
<!--     unique(cleaning_log[[cleaning_log_change_type_column]])[!unique(cleaning_log[[cleaning_log_change_type_column]]) %in% all_type] -->
<!--   if (length(check_not_entry_value_in_change_type) > 0) { -->
<!--     print(check_not_entry_value_in_change_type) -->
<!--     stop("Missing values in change_type") -->
<!--   } -->

<!--   ### TODO -- recheck that this is the correct check.. - it can be acceptable to have only one single change... -->
<!--   # assertthat::assert_that(all(cleaning_log[[cleaning_log_change_type_column]] %in% all_type), -->
<!--   #                         msg = "You have missing change_type option(s)") -->

<!--   cleaning_log[[cleaning_log_question_column]] <- -->
<!--     cleaning_log[[cleaning_log_question_column]] %>% trimws() -->
<!--   cleaning_log[[cleaning_log_new_value_column]] <- -->
<!--     cleaning_log[[cleaning_log_new_value_column]] %>% trimws() -->
<!--   cl_change_type_options <- -->
<!--     c("change_response", -->
<!--       "remove_survey", -->
<!--       "blank_response", -->
<!--       "no_action") -->
<!--   cl_change_response <- -->
<!--     cleaning_log %>% dplyr::filter(change_type_created_f %in% c(cl_change_type_options[1], cl_change_type_options[3])) -->
<!--   cl_change_response <- cl_change_response %>% -->
<!--     dplyr::mutate( -->
<!--       !!cleaning_log_new_value_column := ifelse( -->
<!--         change_type_created_f == cl_change_type_options[3], -->
<!--         NA, -->
<!--         !!rlang::sym(cleaning_log_new_value_column) -->
<!--       ) -->
<!--     ) -->
<!--   cl_remove_survey <- -->
<!--     cleaning_log %>% dplyr::filter(change_type_created_f == cl_change_type_options[2]) -->

<!--   if (all(cl_change_response[[cleaning_log_question_column]] %in% colnames(raw_dataset)) == F) { -->
<!--     problem_question_in_cl <- -->
<!--       cl_change_response[[cleaning_log_question_column]][cl_change_response[[cleaning_log_question_column]] %in% colnames(raw_dataset) == FALSE] -->
<!--     print(paste0(problem_question_in_cl, ": Not found in the dataset")) -->
<!--   } -->

<!--   if (all(cleaning_log[[cleaning_log_uuid_column]] %in% raw_dataset[[raw_data_uuid_column]] == F)) { -->
<!--     problem_uuid_in_cl <- -->
<!--       cleaning_log[[cleaning_log_uuid_column]][cleaning_log[[cleaning_log_uuid_column]] %in% c(raw_dataset[[raw_data_uuid_column]], "all_data") == FALSE] -->
<!--     print(problem_uuid_in_cl) -->
<!--     print("Not found in the datase") -->
<!--   } -->
<!--   assertthat::assert_that(all(cl_change_response[[cleaning_log_question_column]] %in% colnames(raw_dataset)), -->
<!--                           msg = "Make sure all names in cleaning_log_question_column values in the cleaning log are in dataset") -->
<!--   assertthat::assert_that(all(cleaning_log[[cleaning_log_uuid_column]] %in% raw_dataset[[raw_data_uuid_column]]), -->
<!--                           msg = "Make sure all uuids in cleaing log are in data set") -->

<!--   if (nrow(cl_change_response) > 0) { -->
<!--     for (i in 1:nrow(cl_change_response)) { -->
<!--       print(cl_change_response[[cleaning_log_question_column]][i]) -->
<!--       cl_uuid_temp <- -->
<!--         cl_change_response[[cleaning_log_uuid_column]][i] -->
<!--       cl_question_temp <- -->
<!--         cl_change_response[[cleaning_log_question_column]][i] -->
<!--       cl_new_val_temp <- -->
<!--         cl_change_response[[cleaning_log_new_value_column]][i] -->

<!--       if (cl_uuid_temp != "all_data") { -->
<!--         raw_dataset[raw_dataset[[raw_data_uuid_column]] == cl_uuid_temp, cl_question_temp] <- -->
<!--           cl_new_val_temp -->
<!--       } -->

<!--       if (cl_uuid_temp == "all_data") { -->
<!--         raw_dataset[, cl_question_temp] <- cl_new_val_temp -->
<!--       } -->
<!--     } -->
<!--   } else { -->
<!--     print("no change_response in log") -->
<!--   } -->
<!--   if (nrow(cl_remove_survey) > 0) { -->
<!--     raw_dataset <- -->
<!--       raw_dataset %>% dplyr::filter(!!rlang::sym(raw_data_uuid_column) %in% cl_remove_survey[[cleaning_log_uuid_column]] == FALSE) -->
<!--   } else { -->
<!--     print("no surveys to remove in log") -->
<!--   } -->

<!--   return(raw_dataset %>% utils::type.convert(as.is = T)) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-create_clean_data} -->

<!-- cleaning_log_test <- data.frame( -->
<!--   uuid = paste0("uuid", 1:4), -->
<!--   question = c("age", "gender", "pop_group", "strata"), -->
<!--   change_type = c("blank_response", "no_change", "Delete", "change_res"), -->
<!--   new_value = c(NA_character_, NA_character_, NA_character_, "st-a") -->
<!-- ) -->

<!-- test_data <- data.frame( -->
<!--   uuid = paste0("uuid", 1:4), -->
<!--   age = c(180, 23, 45, 67), -->
<!--   gender = c("male", "female", "male", "female"), -->
<!--   pop_group = c("idp", "refugee", "host", "idp"), -->
<!--   strata = c("a", "b", "c", "d") -->
<!-- ) -->

<!-- review_cleaning_log( -->
<!--   raw_dataset = test_data, -->
<!--   raw_data_uuid_column = "uuid", -->
<!--   cleaning_log = cleaning_log_test, -->
<!--   cleaning_log_change_type_column = "change_type", -->
<!--   change_response_value = "change_res", -->
<!--   cleaning_log_question_column = "question", -->
<!--   cleaning_log_uuid_column = "uuid", -->
<!--   cleaning_log_new_value_column = "new_value") -->

<!-- create_clean_data(  raw_dataset = test_data, raw_data_uuid_column = "uuid",  -->
<!--                     cleaning_log = cleaning_log_test, -->
<!--                     cleaning_log_change_type_column = "change_type", -->
<!--                     change_response_value = "change_res", -->
<!--                     NA_response_value = "blank_response", -->
<!--                     no_change_value = "no_change", -->
<!--                     remove_survey_value = "Delete", -->
<!--                     cleaning_log_question_column = "question", -->
<!--                     cleaning_log_uuid_column = "uuid", -->
<!--                     cleaning_log_new_value_column = "new_value") |> -->
<!--   knitr::kable() -->
<!-- ``` -->

<!-- ```{r tests-create_clean_data} -->
<!-- test_that("create_clean_data works", { -->
<!--   expect_true(inherits(create_clean_data, "function"))  -->
<!-- }) -->
<!-- ``` -->



<!-- # REVIEW Functions  -->

<!-- ## review_cleaning_log -->

<!-- ```{r function-review_cleaning_log} -->
<!-- #' check cleaning log -->
<!-- #' @param raw_dataset Raw dataset -->
<!-- #' @param raw_data_uuid_column uuid column in the raw dataset. Default is "uuid". -->
<!-- #' @param cleaning_log cleaning log (data.frame) -->
<!-- #' @param cleaning_log_uuid_column uuid column in the cleaning log. Default is "uuid". -->
<!-- #' @param cleaning_log_question_column column in cleaning log which specifies data set column to change -->
<!-- #' @param cleaning_log_new_value_column cleaning log column specifying the new correct value -->
<!-- #' @param cleaning_log_change_type_column column in cleaning log which specifies change type to be made -->
<!-- #' @param change_response_value values in change type column which should be changed to a new value. -->
<!-- #' @return cleaning log with only problematic entries and note specifying problem -->
<!-- #' @export -->


<!-- review_cleaning_log <- function(raw_dataset, -->
<!--                                raw_data_uuid_column = "uuid", -->
<!--                                cleaning_log, -->
<!--                                cleaning_log_uuid_column = "uuid", -->
<!--                                cleaning_log_question_column, -->
<!--                                cleaning_log_new_value_column, -->
<!--                                cleaning_log_change_type_column, -->
<!--                                change_response_value = "change_response") { -->

<!--   cleaning_log[[cleaning_log_question_column]] <- -->
<!--     cleaning_log[[cleaning_log_question_column]] %>% trimws() -->
<!--   cleaning_log[[cleaning_log_new_value_column]] <- -->
<!--     cleaning_log[[cleaning_log_new_value_column]] %>% trimws() -->


<!--   assertthat::assert_that(cleaning_log_change_type_column %in% names(cleaning_log), -->
<!--                           msg = "cleaning_log_change_type_column column not found in cleaning log") -->

<!--   assertthat::assert_that(all(change_response_value %in% cleaning_log[[cleaning_log_change_type_column]]), -->
<!--                           msg = "Value in change_response_value not found") -->

<!--   cl_change_col_prob_df <- cleaning_log %>% -->
<!--     dplyr::filter(!!rlang::sym(cleaning_log_change_type_column) %in% change_response_value) %>% -->
<!--     dplyr::mutate(cl_prob = "question_does_not_exist") %>% -->
<!--     dplyr::filter(!!rlang::sym(cleaning_log_question_column) %in% colnames(raw_dataset) == FALSE) %>% -->
<!--     dplyr::select(cl_prob, dplyr::everything()) -->

<!--   cl_uuid_prob_df <- cleaning_log %>% -->
<!--     dplyr::filter(!!rlang::sym(cleaning_log_uuid_column) %in% c(raw_dataset[[raw_data_uuid_column]], "all_data") == FALSE) %>% -->
<!--     dplyr::mutate(cl_prob = "uuid_does_not_exist") %>% -->
<!--     dplyr::filter(!!rlang::sym(cleaning_log_uuid_column) %in% raw_dataset[[raw_data_uuid_column]] == FALSE) %>% -->
<!--     dplyr::select(cl_prob, dplyr::everything()) -->

<!--   na_change_type_prob_df <- cleaning_log %>% -->
<!--     dplyr::filter(is.na(!!rlang::sym(cleaning_log_change_type_column))) %>% -->
<!--     dplyr::mutate(cl_prob = "na_in_change_type") %>% -->
<!--     dplyr::select(cl_prob, dplyr::everything()) -->

<!--   cl_problems_df <- -->
<!--     dplyr::bind_rows(get0("cl_change_col_prob_df"), get0("cl_uuid_prob_df")) |> -->
<!--     dplyr::bind_rows(get0("na_change_type_prob_df")) -->

<!--   if (nrow(cl_problems_df) > 0) { -->
<!--     print("cleaning log has issues, see output table") -->
<!--   } else { -->
<!--     cl_problems_df <- "no issues in cleaning log found" -->
<!--   } -->
<!--   return(cl_problems_df) -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-review_cleaning_log} -->
<!-- #review_cleaning_log() -->
<!-- ``` -->

<!-- ```{r tests-review_cleaning_log} -->
<!-- test_that("review_cleaning_log works", { -->
<!--   expect_true(inherits(review_cleaning_log, "function"))  -->
<!-- }) -->
<!-- ``` -->



<!-- ## review_cleaning -->

<!-- ```{r function-review_cleaning} -->
<!-- #' Review cleaning logs -->
<!-- #' @param raw_dataset Raw dataset -->
<!-- #' @param raw_dataset_uuid_column uuid column in the raw dataset. Default is "uuid". -->
<!-- #' @param clean_dataset Clean dataset -->
<!-- #' @param clean_dataset_uuid_column uuid column in the raw dataset. Default is "uuid". -->
<!-- #' @param cleaning_log Cleaning log -->
<!-- #' @param cleaning_log_uuid_column uuid column in the raw dataset. Default is "uuid". -->
<!-- #' @param cleaning_log_change_type_column column in cleaning log which specifies which change to be made -->
<!-- #' @param cleaning_log_question_column column in cleaning log which specifies which column to change -->
<!-- #' @param cleaning_log_new_value_column cleaning log column specifying the new correct value -->
<!-- #' @param cleaning_log_old_value_column cleaning log column specifying the old value -->
<!-- #' @param cleaning_log_added_survey_value Value for change type column which defines for new surveys -->
<!-- #' @param cleaning_log_no_change_value Value for change type column which defines for no action needed -->
<!-- #' @param deletion_log deletion log -->
<!-- #' @param deletion_log_uuid_column Unique ID column name of deletion log -->
<!-- #' @param check_for_deletion_log TRUE to flag the removed survey -->
<!-- #' @return Discrepancy in cleaning log -->
<!-- #' @export -->

<!-- review_cleaning <- function(raw_dataset, -->
<!--                                 raw_dataset_uuid_column = "uuid", -->
<!--                                 clean_dataset, -->
<!--                                 clean_dataset_uuid_column = "uuid", -->
<!--                                 cleaning_log = cleaning_log_only, -->
<!--                                 cleaning_log_uuid_column = "uuid", -->
<!--                                 cleaning_log_change_type_column = "change_type", -->
<!--                                 cleaning_log_question_column = "question", -->
<!--                                 cleaning_log_new_value_column = "new_value", -->
<!--                                 cleaning_log_old_value_column = "old_value", -->
<!--                                 cleaning_log_added_survey_value = "added_survey", -->
<!--                                 cleaning_log_no_change_value = c("no_action", "no_change"), -->
<!--                                 deletion_log = NULL, -->
<!--                                 deletion_log_uuid_column = NULL, -->
<!--                                 check_for_deletion_log = T) { -->
<!--   ## creating list to store missing values -->
<!--   missing_in_cleaning_log <- list() -->


<!--   if (check_for_deletion_log == T) { -->
<!--     if (is.null(deletion_log)) { -->
<!--       stop("Please provide deletion log") -->
<!--     } -->
<!--     if (is.null(deletion_log_uuid_column)) { -->
<!--       stop("Please provide deletion log uuid") -->
<!--     } -->
<!--     if (!deletion_log_uuid_column %in% names(deletion_log)) { -->
<!--       stop("Deletion log uuid not found") -->
<!--     } -->
<!--   } -->

<!--   if (!clean_dataset_uuid_column %in% names(clean_dataset)) { -->
<!--     stop("Clean data uuid not found") -->
<!--   } -->
<!--   if (!raw_dataset_uuid_column %in% names(raw_dataset)) { -->
<!--     stop("Raw data uuid not found") -->
<!--   } -->
<!--   if (!cleaning_log_change_type_column %in% names(cleaning_log)) { -->
<!--     stop("Cleaning log change type column is not found") -->
<!--   } -->
<!--   if (!cleaning_log_question_column %in% names(cleaning_log)) { -->
<!--     stop("Cleaning log question column is not found") -->
<!--   } -->
<!--   if (!cleaning_log_new_value_column %in% names(cleaning_log)) { -->
<!--     stop("Cleaning log new value column is not found") -->
<!--   } -->
<!--   if (!cleaning_log_old_value_column %in% names(cleaning_log)) { -->
<!--     stop("Cleaning log old value column is not found") -->
<!--   } -->

<!--   clean_dataset <- clean_dataset %>% -->
<!--     dplyr::mutate(dplyr::across( -->
<!--       .cols = tidyselect::everything(), -->
<!--       .fns = ~ coerce_to_character(.x))) -->
<!--   raw_dataset <- raw_dataset %>% -->
<!--     dplyr::mutate(dplyr::across( -->
<!--       .cols = tidyselect::everything(), -->
<!--       .fns = ~ coerce_to_character(.x))) -->

<!--   ### unifying cleaning and deletation log -->
<!--   cleaning_log <- cleaning_log %>% -->
<!--     dplyr::mutate(dplyr::across( -->
<!--       .cols = tidyselect::everything(), -->
<!--       .fns = ~ coerce_to_character(.x))) -->
<!--   cleaning_log <- cleaning_log %>% dplyr::rename(uuid = !!rlang::sym(cleaning_log_uuid_column)) -->
<!--   cleaning_log$uniqe_row_id <- -->
<!--     paste0(cleaning_log$uuid, "_", cleaning_log[[cleaning_log_question_column]]) -->
<!--   cleaning_log$uniqe_row_id <- -->
<!--     cleaning_log$uniqe_row_id %>% tolower() -->

<!--   if (check_for_deletion_log == T) { -->
<!--     deletion_log <- deletion_log %>% -->
<!--       dplyr::mutate(dplyr::across( -->
<!--         .cols = tidyselect::everything(), -->
<!--         .fns = ~ coerce_to_character(.x))) -->
<!--     deletion_log <- deletion_log %>% dplyr::rename(uuid = !!rlang::sym(deletion_log_uuid_column)) -->

<!--     to_remove_from_cl_uuid <- -->
<!--       cleaning_log$uuid[cleaning_log$uuid %in% deletion_log$uuid] |> unique() -->

<!--     missing_in_cleaning_log[["cleaning_log_deletion_log_duplication"]] <- -->
<!--       cleaning_log |> -->
<!--       dplyr::filter(uuid %in% to_remove_from_cl_uuid) |> -->
<!--       dplyr::mutate(comment = "UUID found in deletion log. Please remove the entry.") |> -->
<!--       dplyr::select(dplyr::any_of( -->
<!--         c( -->
<!--           "uuid", -->
<!--           cleaning_log_change_type_column, -->
<!--           cleaning_log_question_column, -->
<!--           cleaning_log_new_value_column, -->
<!--           cleaning_log_old_value_column, -->
<!--           "comment" -->
<!--         ) -->
<!--       )) |> -->
<!--       dplyr::rename( -->
<!--         df.change_type = !!rlang::sym(cleaning_log_change_type_column), -->
<!--         df.question = !!rlang::sym(cleaning_log_question_column), -->
<!--       ) -->

<!--     cleaning_log <- -->
<!--       cleaning_log |> dplyr::filter(!uuid %in% deletion_log$uuid) -->
<!--   } -->

<!--   if (nrow(cleaning_log) > 0) { -->
<!--     ## removing no action -->
<!--     cleaning_log_no_action <- cleaning_log |> -->
<!--       dplyr::filter( -->
<!--         !!rlang::sym(cleaning_log_change_type_column) %in% cleaning_log_no_change_value -->
<!--       ) -->
<!--   } -->

<!--   if (nrow(cleaning_log) > 0) { -->
<!--     if (nrow(cleaning_log_no_action) > 0) { -->
<!--       ## log for no action check -->
<!--       missing_in_cleaning_log[["no_action_issue"]] <- -->
<!--         cleaning_log_no_action |> -->
<!--         dplyr::filter(!(!!rlang::sym(cleaning_log_new_value_column)) == (!!rlang::sym(cleaning_log_old_value_column)) | -->
<!--                         ((is.na( -->
<!--                           !!rlang::sym(cleaning_log_new_value_column) -->
<!--                         )) & (!is.na( -->
<!--                           !!rlang::sym(cleaning_log_old_value_column) -->
<!--                         ))) | -->
<!--                         ((!is.na( -->
<!--                           !!rlang::sym(cleaning_log_new_value_column) -->
<!--                         )) & (is.na( -->
<!--                           !!rlang::sym(cleaning_log_old_value_column) -->
<!--                         )))) |> -->
<!--         dplyr::mutate(comment = "No action with different value in new value column.") |> -->
<!--         dplyr::rename( -->
<!--           df.change_type = !!rlang::sym(cleaning_log_change_type_column), -->
<!--           df.question = !!rlang::sym(cleaning_log_question_column), -->
<!--         ) -->
<!--     } -->
<!--   } -->

<!--   if (nrow(cleaning_log) > 0) { -->
<!--     cleaning_log <- cleaning_log |> -->
<!--       dplyr::filter(!(!!rlang::sym(cleaning_log_change_type_column)) %in% cleaning_log_no_change_value) -->
<!--   } -->

<!--   ### generating cleaning log from clean and raw data -->
<!--   cleaning_log_create <- create_cleaning_log( -->
<!--     raw_dataset = raw_dataset, -->
<!--     raw_dataset_uuid_column = raw_dataset_uuid_column, -->
<!--     clean_dataset = clean_dataset, -->
<!--     clean_dataset_uuid_column = clean_dataset_uuid_column, -->
<!--     check_for_variable_name = F -->
<!--   ) %>% dplyr::select(!dplyr::any_of("comment")) -->
<!--   if (nrow(cleaning_log_create) > 0) { -->
<!--     names(cleaning_log_create) <- -->
<!--       paste0("df.", names(cleaning_log_create)) -->
<!--   } -->

<!--   ######################################################################################################### -->
<!--   ##################### Starts changes not applied ######################################################## -->
<!--   ######################################################################################################### -->
<!--   # -->
<!--   clean_data_to_join <- clean_dataset %>% -->
<!--     tidyr::pivot_longer( -->
<!--       cols = !dplyr::all_of(clean_dataset_uuid_column), -->
<!--       names_to = "question", -->
<!--       values_to = "df.new_value" -->
<!--     ) %>% -->
<!--     dplyr::mutate(uniqe_row_id = paste0(!!rlang::sym(clean_dataset_uuid_column), "_", question)) %>% -->
<!--     dplyr::select("uniqe_row_id", "df.new_value") -->
<!--   clean_data_to_join$uniqe_row_id <- -->
<!--     clean_data_to_join$uniqe_row_id %>% tolower() -->

<!--   raw_data_to_join <- raw_dataset %>% -->
<!--     tidyr::pivot_longer( -->
<!--       cols = !dplyr::all_of(raw_dataset_uuid_column), -->
<!--       names_to = "question", -->
<!--       values_to = "df.old_value" -->
<!--     ) %>% -->
<!--     dplyr::mutate(uniqe_row_id = paste0(!!rlang::sym(raw_dataset_uuid_column), "_", question)) %>% -->
<!--     dplyr::select("uniqe_row_id", "df.old_value") -->
<!--   raw_data_to_join$uniqe_row_id <- -->
<!--     raw_data_to_join$uniqe_row_id %>% tolower() -->

<!--   missing_in_cleaning_log[["cleaning_log_no_applied"]] <- -->
<!--     cleaning_log %>% -->
<!--     dplyr::left_join(clean_data_to_join, by = "uniqe_row_id") %>% -->
<!--     dplyr::filter((( -->
<!--       !!rlang::sym(cleaning_log_new_value_column) != df.new_value -->
<!--     ) == T) | -->
<!--       (!is.na( -->
<!--         !!rlang::sym(cleaning_log_new_value_column) -->
<!--       ) & is.na(df.new_value)) | -->
<!--       (is.na( -->
<!--         !!rlang::sym(cleaning_log_new_value_column) -->
<!--       ) & !is.na(df.new_value))) %>% -->
<!--     dplyr::mutate(comment = "Changes were not applied") %>% -->
<!--     dplyr::left_join(raw_data_to_join, by = "uniqe_row_id") %>% -->
<!--     dplyr::rename( -->
<!--       df.question = !!rlang::sym(cleaning_log_question_column), -->
<!--       df.change_type = !!rlang::sym(cleaning_log_change_type_column), -->
<!--     ) %>% -->
<!--     dplyr::select(-"uniqe_row_id") -->

<!--   ###################################################################################################### -->
<!--   #################### end:: changes not applied ######################################################## -->
<!--   ###################################################################################################### -->

<!--   ## checking if all the deleted survey is in deletion log -->
<!--   if (check_for_deletion_log == T) { -->
<!--     if (nrow(cleaning_log_create) > 0) { -->
<!--       created_deletion_log <- -->
<!--         cleaning_log_create[cleaning_log_create$df.change_type == "remove_survey", "df.uuid"] %>% unique() -->
<!--       missing_in_deletion_log <- -->
<!--         created_deletion_log[!created_deletion_log %in% deletion_log$uuid] -->

<!--       if (length(missing_in_deletion_log) != 0) { -->
<!--         missing_in_cleaning_log[["missing_in_deletion_log"]] <- data.frame(uuid = missing_in_deletion_log, -->
<!--                                                                            df.change_type = "remove_survey", -->
<!--                                                                            comment = "This survey was removed but currently missing in cleaning log") -->
<!--       } -->
<!--     } -->
<!--     ### check if all the uuid in deletion log are removed or not -->

<!--     deletion_log_uuid_only <- -->
<!--       deletion_log[[deletion_log_uuid_column]] %>% unique() -->
<!--     deletion_log_not_applied <- -->
<!--       deletion_log_uuid_only[deletion_log_uuid_only %in% clean_dataset[[clean_dataset_uuid_column]]] -->
<!--     deletion_log_not_applied <- -->
<!--       deletion_log_not_applied[deletion_log_not_applied %in% raw_dataset[[raw_dataset_uuid_column]]] -->


<!--     if (length(deletion_log_not_applied) != 0) { -->
<!--       missing_in_cleaning_log[["deletion_log_not_applied"]] <- data.frame(uuid = deletion_log_not_applied, -->
<!--                                                                           df.change_type = "remove_survey", -->
<!--                                                                           comment = "This survey should be deleted from the clean dataset but it was not deleted") -->
<!--     } -->

<!--     ## deletation log check agnist raw data -->
<!--     deletion_log_not_found <- -->
<!--       deletion_log$uuid[!deletion_log$uuid %in% raw_dataset[[raw_dataset_uuid_column]]] -->

<!--     if (length(deletion_log_not_found) > 0) { -->
<!--       missing_in_cleaning_log[["deletion_log_not_found_in_raw_data"]] <- -->
<!--         data.frame(uuid = deletion_log_not_found, -->
<!--                    df.change_type = NA_character_, -->
<!--                    comment = "This survey should be removed from deletion log as it doesn't exist in the raw data.") -->
<!--     } -->
<!--   } -->

<!--   ### check if added_survey was actually added in the dataset -->
<!--   if (nrow(cleaning_log) > 0) { -->
<!--     added_survey_df <- -->
<!--       cleaning_log |> dplyr::filter( -->
<!--         !!rlang::sym(cleaning_log_change_type_column) %in% cleaning_log_added_survey_value -->
<!--       ) -->
<!--     added_survey_df_uuid <- added_survey_df$uuid -->


<!--     if (length(added_survey_df_uuid) > 0) { -->
<!--       missing_in_cleaning_log[["not_added_in_the_cl"]] <- data.frame(uuid = added_survey_df_uuid[!added_survey_df_uuid %in% clean_dataset[[clean_dataset_uuid_column]]]) |> dplyr::mutate( -->
<!--         comment = "This survey should be added in the clean dataset but its missing now", -->
<!--         df.change_type = "added_survey", -->
<!--         df.new_value = NA_character_, -->
<!--         df.question = NA_character_ -->
<!--       ) -->
<!--     } -->
<!--   } -->

<!--   ## checking duplicate entry in cleaning log -->
<!--   cleaning_log_short <- -->
<!--     cleaning_log[, c("uniqe_row_id", cleaning_log_new_value_column)] -->
<!--   cleaning_log_short <- -->
<!--     apply(cleaning_log_short, MARGIN = c(1, 2), tolower) %>% as.data.frame() ### make everything to lower to compare the new_value -->
<!--   duplicate_id_long_list <- -->
<!--     cleaning_log_short$uniqe_row_id[duplicated(cleaning_log_short$uniqe_row_id)] -->

<!--   duplicate_entry_in_cleaning_log <- -->
<!--     cleaning_log_short[cleaning_log_short$uniqe_row_id %in% duplicate_id_long_list,] -->

<!--   ## to check -->
<!--   final_duplicated <- -->
<!--     duplicate_entry_in_cleaning_log[!( -->
<!--       duplicated(duplicate_entry_in_cleaning_log) | -->
<!--         duplicated(duplicate_entry_in_cleaning_log, -->
<!--                    fromLast = TRUE) -->
<!--     ),] -->

<!--   final_duplicate_df <- -->
<!--     cleaning_log[cleaning_log$uniqe_row_id %in% final_duplicated$uniqe_row_id,] |> dplyr::mutate(comment = "Duplicated entry with different value, please recheck and keep one") -->
<!--   final_duplicate_df$df.question <- -->
<!--     final_duplicate_df[[cleaning_log_question_column]] -->

<!--   if (nrow(final_duplicate_df) > 0) { -->
<!--     missing_in_cleaning_log[["duplicated_entry_with_different_value"]] <- -->
<!--       final_duplicate_df[, c( -->
<!--         "uuid", -->
<!--         "df.question", -->
<!--         cleaning_log_old_value_column, -->
<!--         cleaning_log_new_value_column, -->
<!--         "comment" -->
<!--       )] -->
<!--   } -->

<!--   ## check for change log -->
<!--   if (nrow(cleaning_log_create) > 0) { -->
<!--     cleaning_log_create_change_response <- -->
<!--       cleaning_log_create[!cleaning_log_create$df.change_type %in% c("variable_removed", "remove_survey"),] -->

<!--     cleaning_log_create_change_response <- -->
<!--       cleaning_log_create_change_response |> -->
<!--       dplyr::mutate(uniqe_row_id = tolower( -->
<!--         paste0( -->
<!--           cleaning_log_create_change_response$df.uuid, -->
<!--           "_", -->
<!--           cleaning_log_create_change_response$df.question -->
<!--         ) -->
<!--       )) -->
<!--     cl_to_add <- -->
<!--       cleaning_log[, c("uniqe_row_id", cleaning_log_new_value_column)] -->


<!--     if (nrow(cleaning_log_create_change_response) > 0) { -->
<!--       missing_in_cleaning_log[["value_check"]] <- -->
<!--         cleaning_log_create_change_response %>% -->
<!--         dplyr::mutate(check_in_given_log = uniqe_row_id %in% cl_to_add$uniqe_row_id) %>% -->
<!--         dplyr::left_join(cl_to_add, multiple = "all", by = "uniqe_row_id") %>% -->
<!--         dplyr::mutate(new_value_check = dplyr::case_when( -->
<!--           is.na(df.new_value) & -->
<!--             is.na(!!rlang::sym(cleaning_log_new_value_column)) ~ T, -->
<!--           ( -->
<!--             df.new_value == !!rlang::sym(cleaning_log_new_value_column) -->
<!--           ) == T ~ T, -->
<!--           T ~ F -->
<!--         )) %>% -->
<!--         dplyr::mutate( -->
<!--           comment = dplyr::case_when( -->
<!--             check_in_given_log == F ~ "Entry missing in cleaning log", -->
<!--             new_value_check == F ~ "New value in cleaning log and value in clean dataset not matching" -->
<!--           ) -->
<!--         ) %>% -->
<!--         dplyr::filter(!is.na(comment)) %>% -->
<!--         dplyr::rename(uuid = df.uuid) -->
<!--     } -->
<!--   } -->

<!--   lookup <- c(cl.old_value = cleaning_log_old_value_column, -->
<!--               cl.new_value = cleaning_log_new_value_column) -->

<!--   cleaning_log_issue <- -->
<!--     do.call(dplyr::bind_rows, missing_in_cleaning_log) %>% -->
<!--     dplyr::select(dplyr::any_of( -->
<!--       c( -->
<!--         "uuid", -->
<!--         "df.question", -->
<!--         "df.change_type", -->
<!--         "df.new_value", -->
<!--         cleaning_log_new_value_column, -->
<!--         "df.old_value", -->
<!--         cleaning_log_old_value_column, -->
<!--         "comment" -->
<!--       ) -->
<!--     )) %>% -->
<!--     dplyr::rename(dplyr::any_of(lookup)) -->

<!--   return(cleaning_log_issue |> dplyr::mutate( -->
<!--     comment = dplyr::case_when( -->
<!--       df.change_type == "added_survey" & -->
<!--         comment == "Entry missing in cleaning log" ~ "Survey missing in the raw data", -->
<!--       T ~ comment -->
<!--     ) -->
<!--   )) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-review_cleaning} -->

<!-- deletion_log<- cleaningtools::cleaningtools_cleaning_log |> -->
<!--   dplyr::filter(change_type == "remove_survey") -->

<!-- cleaning_log <- cleaningtools::cleaningtools_cleaning_log |> -->
<!--   dplyr::filter(change_type != "remove_survey") -->

<!-- # review_cleaning(  raw_dataset = cleaningtools::raw_dataset,  -->
<!-- #                   raw_dataset_uuid_column = "X_uuid", -->
<!-- #                   clean_dataset = cleaningtools::clean_dataset,  -->
<!-- #                   clean_dataset_uuid_column = "X_uuid", -->
<!-- #                   cleaning_log = cleaning_log2,  -->
<!-- #                   cleaning_log_uuid_column = "X_uuid", -->
<!-- #                   cleaning_log_question_column = "questions", -->
<!-- #                   cleaning_log_new_value_column = "new_value", -->
<!-- #                   cleaning_log_old_value_column = "old_value", -->
<!-- #                   deletion_log = deletaion_log, -->
<!-- #                   deletion_log_uuid_column = "X_uuid", -->
<!-- #                   check_for_deletion_log = T) |> -->
<!-- #   knitr::kable() -->

<!-- ``` -->

<!-- ```{r tests-review_cleaning} -->
<!-- test_that("review_cleaning works", { -->
<!--   expect_true(inherits(review_cleaning, "function"))  -->
<!-- }) -->
<!-- ``` -->


<!-- ## review_others -->

<!-- ```{r function-review_others} -->
<!-- #' Review discrepancy between kobo relevancies and the dataset. -->
<!-- #' -->
<!-- #' @param dataset dataset to be check -->
<!-- #' @param uuid_column uuid column in the dataset. Default is "uuid". -->
<!-- #' @param kobo_survey Kobo survey sheet. -->
<!-- #' @param sm_separator Separator for choice multiple questions. The default is "." -->
<!-- #' @param information_to_add string vector optional, if to add some information to the log (today,village etc.) -->
<!-- #' @param columns_not_to_check Columns to exclude from the checks -->
<!-- #' @return Any discrepancy between kobo relevancies and the dataset. -->
<!-- #' @export -->

<!-- review_others <- function(dataset, -->
<!--                           uuid_column = "uuid", -->
<!--                           kobo_survey, -->
<!--                           sm_separator = ".", -->
<!--                           information_to_add = NULL, -->
<!--                           columns_not_to_check = NULL) { -->
<!--   ### variables to add not found -->
<!--   if (any(!information_to_add %in% names(dataset))) { -->
<!--     not_found <- information_to_add[!information_to_add %in% names(dataset)] -->

<!--     msg <- not_found |> -->
<!--       glue::glue_collapse(sep = ", ") %>% -->
<!--       glue::glue("Following variables: ", ., " cannot be found in the dataset.") -->
<!--     stop(msg) -->
<!--   } -->

<!--   ### columns_not_to_check not found [warning] -->

<!--   if (any(!columns_not_to_check %in% names(dataset))) { -->
<!--     not_found <- columns_not_to_check[!columns_not_to_check %in% names(dataset)] -->

<!--     msg <- not_found |> -->
<!--       glue::glue_collapse(sep = ", ") %>% -->
<!--       glue::glue("Following variables: ", ., " cannot be found in the dataset.") -->
<!--     warning(msg) -->
<!--   } -->


<!--   ### UUID checkk error -->

<!--   if (!uuid_column %in% names(dataset)) { -->
<!--     stop(paste0(uuid_column, " not found in the dataset.")) -->
<!--   } -->


<!--   all_logic <- create_logic_for_other( -->
<!--     kobo_survey = kobo_survey, -->
<!--     compare_with_dataset = TRUE, -->
<!--     dataset = dataset, -->
<!--     sm_separator = sm_separator -->
<!--   ) -->



<!--   check <- check_logical_with_list( -->
<!--     dataset = dataset, -->
<!--     uuid_column = uuid_column, -->
<!--     list_of_check = all_logic, -->
<!--     check_id_column = "id", -->
<!--     check_to_perform_column = "logic", -->
<!--     columns_to_clean_column = "variables_to_clean_column", -->
<!--     information_to_add = information_to_add, -->
<!--     description_column = "description", -->
<!--     bind_checks = T -->
<!--   ) -->

<!--   check$logical_all <- check$logical_all |> dplyr::filter(!check$logical_all$question %in% columns_not_to_check) -->
<!--   check$logical_all |> as.data.frame() -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-review_others} -->

<!-- review_others( -->
<!--   dataset = cleaningtools::cleaningtools_clean_data, -->
<!--   uuid_column = "X_uuid", kobo_survey = cleaningtools_survey -->
<!-- ) -->

<!-- ``` -->

<!-- ```{r tests-review_others} -->
<!-- test_that("review_others works", { -->
<!--   expect_true(inherits(review_others, "function"))  -->
<!-- }) -->
<!-- ``` -->


<!-- ## review_sample_frame_with_dataset -->

<!-- ```{r function-review_sample_frame_with_dataset} -->
<!-- #' Compares the sample frame with the clean data -->
<!-- #' -->
<!-- #' @param sample_frame A sample frame. It mush have a column for strata and another column defining the number of needed survey per strata. -->
<!-- #' @param sampling_frame_strata_column Column name for strata in the sample frame -->
<!-- #' @param sampling_frame_target_survey_column Column name defining number of survey per strata in sample frame. -->
<!-- #' @param clean_dataset Clean data -->
<!-- #' @param clean_dataset_strata_column Column name for strata in clean data -->
<!-- #' @param consent_column Dataset consent column -->
<!-- #' @param consent_yes_value Choice for consent yes -->
<!-- #' @return a dataset with the two additional columns with the number of completed surveys and number of remaining survey. -->
<!-- #' @export -->

<!-- review_sample_frame_with_dataset <- function(sample_frame, -->
<!--                                              sampling_frame_strata_column, -->
<!--                                              sampling_frame_target_survey_column = "Total.no.of.HH", -->
<!--                                              clean_dataset, -->
<!--                                              clean_dataset_strata_column, -->
<!--                                              consent_column = "consent", -->
<!--                                              consent_yes_value = "yes") { -->
<!--   if (!consent_column %in% names(clean_dataset)) { -->
<!--     stop(paste0(consent_column, " not found in the clean data")) -->
<!--   } -->

<!--   consent_value_not_found <- consent_yes_value[!consent_yes_value %in% unique(clean_dataset[[consent_column]])] -->
<!--   if (length(consent_value_not_found) > 0) { -->
<!--     stop(paste0(consent_value_not_found, " not found in the consent column")) -->
<!--   } -->


<!--   clean_dataset <- clean_dataset |> dplyr::filter(!!rlang::sym(consent_column) %in% consent_yes_value) -->


<!--   if (!sampling_frame_strata_column %in% names(sample_frame)) { -->
<!--     stop(paste0(sampling_frame_strata_column, " not found in the sample frame")) -->
<!--   } -->
<!--   if (!sampling_frame_target_survey_column %in% names(sample_frame)) { -->
<!--     stop(paste0(sampling_frame_target_survey_column, " not found in the sample frame")) -->
<!--   } -->
<!--   if (!clean_dataset_strata_column %in% names(clean_dataset)) { -->
<!--     stop(paste0(clean_dataset_strata_column, " not found in the clean data")) -->
<!--   } -->
<!--   if (any(names(sample_frame) %in% c("Collected", "Renaming"))) { -->
<!--     warning("Dataset has Collected/Renaming column already, which will be replaced.") -->
<!--   } -->

<!--   cl_unique_strata <- unique(clean_dataset[[clean_dataset_strata_column]]) -->
<!--   if (any(!cl_unique_strata %in% sample_frame[[sampling_frame_strata_column]])) { -->
<!--     print(cl_unique_strata[!cl_unique_strata %in% sample_frame[[sampling_frame_strata_column]]]) -->
<!--     stop("The above strata was not found in the sample frame.") -->
<!--   } -->

<!--   actual_df <- clean_dataset |> -->
<!--     dplyr::group_by(!!rlang::sym(clean_dataset_strata_column)) |> -->
<!--     dplyr::summarise( -->
<!--       Collected = dplyr::n() -->
<!--     ) -->

<!--   sample_frame |> -->
<!--     dplyr::select(-dplyr::any_of(c("Collected", "Remaining"))) |> -->
<!--     dplyr::left_join(actual_df, by = stats::setNames(clean_dataset_strata_column, sampling_frame_strata_column)) |> -->
<!--     dplyr::mutate(Collected = dplyr::case_when(is.na(Collected) ~ 0, T ~ Collected)) |> -->
<!--     dplyr::mutate( -->
<!--       Remaining = !!rlang::sym(sampling_frame_target_survey_column) - Collected -->
<!--     ) -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-review_sample_frame_with_dataset} -->

<!-- review_sample_frame_with_dataset( -->
<!--   sample_frame = cleaningtools::cleaningtools_sample_frame, -->
<!--   sampling_frame_strata_column = "Neighbourhood", -->
<!--   sampling_frame_target_survey_column = "Total.no.of.HH", -->
<!--   clean_dataset = cleaningtools::cleaningtools_clean_data, -->
<!--   clean_dataset_strata_column = "neighbourhood", -->
<!--   consent_column = "consent_remote", -->
<!--   consent_yes_value = "yes" -->
<!-- ) -->
<!-- ``` -->

<!-- ```{r tests-review_sample_frame_with_dataset} -->
<!-- test_that("review_sample_frame_with_dataset works", { -->
<!--   expect_true(inherits(review_sample_frame_with_dataset, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- # UTILITIES functions -->


<!-- ## auto_detect_sm_parents -->

<!-- ```{r function-auto_detect_sm_parents} -->
<!-- #' @name auto_detect_sm_parents -->
<!-- #' @rdname auto_detect_sm_parents -->
<!-- #' @title Detect select multiple parent columns -->
<!-- #' @description `auto_detect_sm_parents` is mean to detect select multiple parent columns in a way that does -->
<!-- #' not rely on the XLSForm as the input -->
<!-- #' @param dataset dataset to correct -->
<!-- #' @param sm_separator Separator for choice multiple questions. The default is "." -->
<!-- #'  If using read_csv to read in data the separator will most likely be '/' where as if using read.csv it will likely be '.' -->
<!-- #' @return a list of select multiple parent columns in data set. -->
<!-- #' @export -->
<!-- auto_detect_sm_parents <- function(dataset, sm_separator = ".") { -->
<!--   sm_parents <- -->
<!--     sub(glue::glue(".[^\\{sm_separator}]*$"), -->
<!--         "", -->
<!--         colnames(dataset)) -->
<!--   sm_parents <- data.frame(col_names = sm_parents[sm_parents != ""]) -->
<!--   select_multiple_detected <- sm_parents %>% -->
<!--     dplyr::group_by(col_names) %>% -->
<!--     dplyr::summarise(n = dplyr::n()) %>% -->
<!--     dplyr::filter(n > 1) %>% -->
<!--     dplyr::select(col_names) -->
<!--   return(as.character(select_multiple_detected$col_names)) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-auto_detect_sm_parents} -->
<!-- #auto_detect_sm_parents() -->
<!-- ``` -->

<!-- ```{r tests-auto_detect_sm_parents} -->
<!-- test_that("auto_detect_sm_parents works", { -->
<!--   expect_true(inherits(auto_detect_sm_parents, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## auto_sm_parent_children -->

<!-- ```{r function-auto_sm_parent_children} -->
<!-- #' @name auto_sm_parent_child -->
<!-- #' @rdname auto_sm_parent_child -->
<!-- #' @title detect and group together select multiple parent and children columns -->
<!-- #' @description `auto_sm_parent_children` is mean to detect select multiple parent columns & children columns in a way that does -->
<!-- #' not rely on the XLSForm as the input -->
<!-- #' @param dataset dataset to correct -->
<!-- #' @param sm_separator Separator for choice multiple questions. The default is "." -->
<!-- #'  If using read_csv to read in data the separator will most likely be '/' where as if using read.csv it will likely be '.' -->
<!-- #' @return a data frame containing the the child select multiple columns alongside there parents and -->
<!-- #' a log with all changes recorded. -->
<!-- #' @export -->


<!-- auto_sm_parent_children <- function(dataset, sm_separator = ".") { -->
<!--   sm_parents <- auto_detect_sm_parents(dataset, sm_separator) -->
<!--   sm_child <- dataset %>% -->
<!--     dplyr::select(dplyr::starts_with(glue::glue("{sm_parents}{sm_separator}"))) %>% -->
<!--     colnames() -->
<!--   dplyr::tibble(sm_parent = sub(glue::glue(".[^\\{sm_separator}]*$"), "", sm_child), -->
<!--                 sm_child) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-auto_sm_parent_children} -->
<!-- #auto_sm_parent_children() -->
<!-- ``` -->

<!-- ```{r tests-auto_sm_parent_children} -->
<!-- test_that("auto_sm_parent_children works", { -->
<!--   expect_true(inherits(auto_sm_parent_children, "function"))  -->
<!-- }) -->
<!-- ``` -->


<!-- ## recreate_parent_column -->

<!-- ```{r function-recreate_parent_column} -->
<!-- #' This function recreates the columns for select multiple questions -->
<!-- #' -->
<!-- #' @param dataset data frame -->
<!-- #' @param uuid_column uuid column in the dataset. Default is "uuid". -->
<!-- #' @param kobo_survey Kobo survey sheet. -->
<!-- #' @param kobo_choices Kobo choices sheet. -->
<!-- #' @param sm_separator Separator for choice multiple questions. The default is "." -->
<!-- #' @param cleaning_log_to_append A cleaning log where to add the changes from this functions. -->
<!-- #' Names of the log from this function are  "uuid", "question", "change_type", "new_value", -->
<!-- #' "old_value", "comment". If the cleaning_log_to_append names are not matching, the only way is to -->
<!-- #' create without a cleaning_log_to_append, and rename the columns and then bind. -->
<!-- #' -->
<!-- #' @export -->

<!-- recreate_parent_column <- function(dataset, -->
<!--                                    uuid_column = "uuid", -->
<!--                                    kobo_survey = NULL, -->
<!--                                    kobo_choices = NULL, -->
<!--                                    sm_separator = ".", -->
<!--                                    cleaning_log_to_append = NULL) { -->
<!--   checked_data <- dataset -->

<!--   initial_order <- names(dataset) -->

<!--   if (is.null(kobo_survey)) { -->
<!--     old_name <- names(dataset) -->
<!--     number_of_separator <- names(dataset) |> -->
<!--       stringr::str_count(pattern = paste0("\\", sm_separator)) |> -->
<!--       max(na.rm = T) -->
<!--     for (i in 1:number_of_separator) { -->
<!--       names(dataset) <- -->
<!--         sub(paste0("(\\", sm_separator, ".*?)\\", sm_separator), -->
<!--             "\\1_", -->
<!--             names(dataset)) -->
<!--     } -->

<!--     cols_order <- dataset %>% names() -->


<!--     difference_df <- dplyr::tibble(old_name = old_name, -->
<!--                                    new_name = cols_order) |> dplyr::filter(old_name != new_name) -->

<!--     if (nrow(difference_df) > 0) { -->
<!--       warning( -->
<!--         "Column(s) names are renamed as multiple separators are found in dataset column names. Please see the above table with the new name." -->
<!--       ) -->

<!--       print(difference_df) -->
<!--     } -->


<!--     select_multiple <- -->
<!--       auto_sm_parent_children(dataset, sm_separator = sm_separator) -->
<!--   } -->

<!--   if (!is.null(kobo_survey)) { -->
<!--     choice_to_join <- kobo_choices |> dplyr::select(list_name, name) -->

<!--     select_multiple <- kobo_survey |> -->
<!--       dplyr::filter(grepl("select_multiple", type)) |> -->
<!--       dplyr::select(type, name) |> -->
<!--       dplyr::mutate(type = stringr::str_replace_all(type, "select_multiple ", "")) |> -->
<!--       dplyr::rename(list_name = type, -->
<!--                     sm_parent = name) |> -->
<!--       dplyr::left_join(choice_to_join, multiple = "all", by = "list_name") |> -->
<!--       dplyr::mutate(sm_child = paste0(sm_parent, sm_separator, name)) |> -->
<!--       dplyr::select(sm_parent, sm_child) -->

<!--     missing_column <- -->
<!--       select_multiple$sm_child[!select_multiple$sm_child %in% names(dataset)] -->

<!--     if (length(missing_column) > 0) { -->
<!--       print(missing_column) -->
<!--       warning(paste0( -->
<!--         "Ignoring the above column(s) as they do not exist in the dataset." -->
<!--       )) -->
<!--     } -->
<!--     select_multiple <- -->
<!--       select_multiple |> dplyr::filter(sm_child %in% names(dataset)) -->
<!--   } -->

<!--   if (nrow(select_multiple) > 0) { -->
<!--     select_multiple_list <- list() -->

<!--     for (i in select_multiple$sm_parent) { -->
<!--       select_multi_single <- -->
<!--         select_multiple %>% dplyr::filter(sm_parent == i) -->
<!--       concat_col <- select_multi_single$sm_parent %>% unique() -->
<!--       choice_cols <- select_multi_single$sm_child %>% unique() -->

<!--       df_only_cols <- -->
<!--         dataset %>% dplyr::select(dplyr::all_of(choice_cols), -->
<!--                                   dplyr::all_of(uuid_column)) -->

<!--       pivot_long <- -->
<!--         df_only_cols %>% dplyr::mutate_at(names(df_only_cols), as.character) -->

<!--       final_df <- pivot_long %>% -->
<!--         tidyr::pivot_longer( -->
<!--           cols = !dplyr::all_of(uuid_column), -->
<!--           names_to = "cols", -->
<!--           values_to = "value" -->
<!--         ) %>% -->
<!--         dplyr::filter(value == 1 | -->
<!--                         value == TRUE | -->
<!--                         value == "1" | value == "TRUE") %>% -->
<!--         dplyr::group_by(!!rlang::sym(uuid_column)) %>% -->
<!--         dplyr::summarise(!!rlang::sym(concat_col) := paste0(cols, collapse = " ")) -->

<!--       final_df[[concat_col]] <- -->
<!--         final_df[[concat_col]] %>% stringr::str_replace_all(paste0(concat_col, "."), "") -->

<!--       select_multiple_list[[concat_col]] <- final_df -->
<!--     } -->

<!--     final_df_for_export <- -->
<!--       purrr::reduce(select_multiple_list, dplyr::full_join, by = uuid_column) -->
<!--     concat_col_names_from_fina_export <- final_df_for_export %>% -->
<!--       dplyr::select(!dplyr::all_of(uuid_column)) %>% -->
<!--       names() -->

<!--     data_with_fix_concat <- dataset %>% -->
<!--       dplyr::select(-dplyr::all_of(concat_col_names_from_fina_export)) %>% -->
<!--       dplyr::left_join(final_df_for_export, by = uuid_column) -->

<!--     if (is.null(kobo_survey)) { -->
<!--       data_with_fix_concat <- -->
<!--         data_with_fix_concat %>% dplyr::select(dplyr::all_of(cols_order)) -->
<!--     } -->
<!--     if (!is.null(kobo_survey)) { -->
<!--       data_with_fix_concat <- -->
<!--         data_with_fix_concat %>% dplyr::select(dplyr::all_of(initial_order)) -->
<!--     } -->

<!--     correction_parent_sm_log <- create_cleaning_log( -->
<!--       raw_dataset = checked_data, -->
<!--       raw_dataset_uuid_column = uuid_column, -->
<!--       clean_dataset = data_with_fix_concat, -->
<!--       clean_dataset_uuid_column = uuid_column -->
<!--     ) -->
<!--     if ("comment" %in% names(correction_parent_sm_log)) { -->
<!--       correction_parent_sm_log <- correction_parent_sm_log %>% -->
<!--         dplyr::mutate( -->
<!--           comment = gsub( -->
<!--             "An alteration was performed", -->
<!--             "Parent column changed to match children columns", -->
<!--             comment -->
<!--           ) -->
<!--         ) -->
<!--     } -->

<!--     if (!is.null(cleaning_log_to_append)) { -->
<!--       list_to_return <- list( -->
<!--         data_with_fix_concat = data_with_fix_concat, -->
<!--         cleaning_log = dplyr::bind_rows(cleaning_log_to_append, -->
<!--                                         correction_parent_sm_log) -->
<!--       ) -->

<!--     } else { -->
<!--       list_to_return <- list(data_with_fix_concat = data_with_fix_concat, -->
<!--                              correction_parent_sm_log = correction_parent_sm_log) -->
<!--     } -->
<!--   } -->

<!--   if (nrow(select_multiple) == 0) { -->
<!--     correction_parent_sm_log <- data.frame(uuid = "all", -->
<!--                                            comment = "No choice multiple questions/Nothing has changed") -->
<!--     list_to_return <- list(data_with_fix_concat = dataset, -->
<!--                            correction_parent_sm_log = correction_parent_sm_log) -->
<!--   } -->

<!--   return(list_to_return) -->

<!-- } -->
<!-- ``` -->

<!-- ```{r example-recreate_parent_column} -->

<!-- test_data <- dplyr::tibble( -->
<!--   uuid = paste0("uuid_", 1:6), -->
<!--   gender = rep(c("male", "female"), 3), -->
<!--   reason = c( -->
<!--     "xx,yy", "xx,zy", -->
<!--     "zy", "xx,xz,zy", -->
<!--     NA_character_, "xz" -->
<!--   ), -->
<!--   reason.xx = c(0, 1, 0, 1, 0, 0), -->
<!--   reason.yy = c(1, 0, 0, 0, 1, 0), -->
<!--   reason.xz = c(0, 0, 0, 1, 0, 1), -->
<!--   reason.zy = c(0, 1, 1, 1, 0, 0), -->
<!--   reason_zy = c(NA_character_, "A", "B", "C", NA_character_, NA_character_) -->
<!-- ) -->
<!-- recreate_parent_column(dataset = test_data, uuid_column = "uuid", sm_separator = ".") -->

<!-- ``` -->

<!-- ```{r tests-recreate_parent_column} -->
<!-- test_that("recreate_parent_column works", { -->
<!--   expect_true(inherits(recreate_parent_column, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## detect_variable -->

<!-- ```{r function-detect_variable} -->
<!-- #' detects variables names in code -->
<!-- #' -->
<!-- #' @param codeintext a string vector to look for variables -->
<!-- #' -->
<!-- #' @return a vector with strings -->
<!-- #' @export -->

<!-- detect_variable <- function(codeintext) { -->

<!--   stop_words_replace <- c("!", "&", "%") -->
<!--   stop_words_functions <- c("na.rm", "TRUE", "FALSE", "T", "F") -->

<!--   var_vector <- codeintext %>% -->
<!--     stringr::str_replace_all(pattern = "[:symbol:]", replace = " ") %>% # removes anything | ` =  + ^ ~ < > $ -->
<!--     stringr::str_replace_all( -->
<!--       pattern = stop_words_replace %>% stringi::stri_c(collapse = "|"), -->
<!--       replace = " " -->
<!--     ) %>% # removes anything ! & % -->

<!--     stringi::stri_split(regex = " ", omit_empty = T) %>% -->
<!--     do.call(c, .) %>% -->
<!--     stringr::str_subset(pattern = "\"", negate = T) %>% # removes anything that starts with a quote -->
<!--     stringr::str_subset(pattern = "^[:digit:]+$", negate = T) %>% # removes anything that is only number -->
<!--     stringr::str_subset(pattern = "[:alnum:]+(?=\\()", negate = T) %>% # removes functions, i.e. text( -->
<!--     stringr::str_replace_all(pattern = "\\(|\\)", " ") %>% # removes parenthesis -->
<!--     stringr::str_replace_all(pattern = "\\(|\\)", " ") %>% -->
<!--     stringr::str_subset( -->
<!--       pattern = stop_words_functions %>% stringi::stri_c(collapse = "|"), -->
<!--       negate = T -->
<!--     ) %>% # removes stop words from functions -->
<!--     stringr::str_trim() %>% -->
<!--     unique() -->

<!--   var_vector[var_vector != ""] -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-detect_variable} -->

<!-- string_to_check <- c( -->
<!--   "ki_age> 1", -->
<!--   "noo==\"mar\"", -->
<!--   "sum(var1, var2, na.rm = T)", -->
<!--   "oks != \"mar2\"", -->
<!--   "oknospace!=\"mar2\"" -->
<!-- ) -->
<!-- detect_variable(string_to_check) -->
<!-- ``` -->

<!-- ```{r tests-detect_variable} -->
<!-- test_that("detect_variable works", { -->
<!--   expect_true(inherits(detect_variable, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## verify_valid_survey -->

<!-- ```{r function-verify_valid_survey} -->
<!-- #' Verify if the Kobo survey dataframe is valid -->
<!-- #' -->
<!-- #' This function checks whether the provided Kobo survey dataframe meets certain criteria: -->
<!-- #' 1. It is a dataframe. -->
<!-- #' 2. It is not empty. -->
<!-- #' 3. It contains columns named "type" and "name". -->
<!-- #' -->
<!-- #' @param kobo_survey A dataframe representing the Kobo survey sheet. -->
<!-- #' -->
<!-- #' @return Logical. Returns `TRUE` if the dataframe meets all the criteria. Otherwise, it returns `FALSE`. -->
<!-- #' -->
<!-- #' @export -->

<!-- verify_valid_survey <- function(kobo_survey) { -->
<!--   if (!is.data.frame(kobo_survey)) { -->
<!--     return(F) -->
<!--   } -->
<!--   if (length(kobo_survey) == 0) { -->
<!--     return(F) -->
<!--   } -->
<!--   if (!all(c("type", "name") %in% names(kobo_survey))) { -->
<!--     return(F) -->
<!--   } -->

<!--   return(TRUE) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-verify_valid_survey} -->

<!-- # Assume df_valid is a valid Kobo survey dataframe -->
<!-- df_valid <- data.frame(type = c("integer", "selecte_one yesno"), name = c("age", "consent")) -->
<!-- verify_valid_survey(df_valid) # should return TRUE -->

<!-- # Assume df_invalid lacks the required columns -->
<!-- df_invalid <- data.frame(column1 = c("integer", "selecte_one yesno"), column2 = c("age", "consent")) -->
<!-- verify_valid_survey(df_invalid) # should return FALSE -->
<!-- ``` -->

<!-- ```{r tests-verify_valid_survey} -->
<!-- test_that("verify_valid_survey works", { -->
<!--   expect_true(inherits(verify_valid_survey, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## verify_valid_choices -->

<!-- ```{r function-verify_valid_choices} -->
<!-- #' Verify if the Kobo choices dataframe is valid -->
<!-- #' -->
<!-- #' This function checks whether the provided Kobo choices dataframe meets certain criteria: -->
<!-- #' 1. It is a dataframe. -->
<!-- #' 2. It is not empty. -->
<!-- #' 3. It contains columns named "list_name" and "name". -->
<!-- #' -->
<!-- #' @param kobo_choices A dataframe representing the Kobo choices sheet. -->
<!-- #' -->
<!-- #' @return Logical. Returns `TRUE` if the dataframe meets all the criteria. Otherwise, it returns `FALSE`. -->
<!-- #' -->
<!-- #' @export -->

<!-- verify_valid_choices <- function(kobo_choices) { -->
<!--   if (!is.data.frame(kobo_choices)) { -->
<!--     return(F) -->
<!--   } -->
<!--   if (length(kobo_choices) == 0) { -->
<!--     return(F) -->
<!--   } -->
<!--   if (!all(c("list_name", "name") %in% names(kobo_choices))) { -->
<!--     return(F) -->
<!--   } -->

<!--   return(TRUE) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-verify_valid_choices} -->

<!-- # Assume df_valid_choices is a valid Kobo choices dataframe -->
<!-- df_valid_choices <- data.frame(list_name = c("ChoiceA", "ChoiceB"), name = c("Option1", "Option2")) -->
<!-- verify_valid_choices(df_valid_choices) # should return TRUE -->

<!-- # Assume df_invalid_choices lacks the required columns -->
<!-- df_invalid_choices <- data.frame(column1 = c("ChoiceA", "ChoiceB"), -->
<!--                                  column2 = c("Option1", "Option2")) -->
<!-- verify_valid_choices(df_invalid_choices) # should return FALSE -->
<!-- ``` -->

<!-- ```{r tests-verify_valid_choices} -->
<!-- test_that("verify_valid_choices works", { -->
<!--   expect_true(inherits(verify_valid_choices, "function"))  -->
<!-- }) -->
<!-- ``` -->


<!-- ## create_validation_list -->

<!-- ```{r function-create_validation_list} -->
<!-- #' Create a Validation List for Data Entry -->
<!-- #' -->
<!-- #' This function generates a validation list to be used for data entry validation. -->
<!-- #' It combines predefined validation lists with dynamically formatted choices derived from -->
<!-- #' the `choices` and `tool` parameters. The resulting dataframe is intended to provide -->
<!-- #' structured and valid choices for various question types. -->
<!-- #' -->
<!-- #' @param choices A dataframe representing the Kobo choices sheet. -->
<!-- #'        Expected to have at least the columns `list_name` and `name`. -->
<!-- #' @param tool A dataframe representing the Kobo survey sheet. -->
<!-- #'        Expected to have at least the columns `type` and `name`. -->
<!-- #' -->
<!-- #' @return A dataframe where each column corresponds to a choice list for a specific question. -->
<!-- #'         Each row contains a valid choice for the question. -->
<!-- #' -->
<!-- #' @export -->
<!-- create_validation_list <- function(choices, tool) { -->
<!--   new_lists <- list( -->
<!--     c("change_type_validation", "change_response;\nblank_response;\nremove_survey;\nno_action"), -->
<!--     c("binaries_sm_options_lgl", "FALSE;\nTRUE"), -->
<!--     c("binaries_sm_options_num", "0;\n1") -->
<!--     # c("_duplicates_","-- keep the survey --;\n-- delete the survey --"), -->
<!--     # c("_action_","-- confirm --;\n-- update --;\n-- delete --") -->
<!--   ) %>% -->
<!--     do.call(rbind, .) %>% -->
<!--     as.data.frame() %>% -->
<!--     stats::setNames(c("name", "choices")) -->

<!--   choicelist <- new_lists %>% -->
<!--     dplyr::bind_rows(create_formatted_choices(choices, tool) %>% -->
<!--       dplyr::select(name, choices)) -->

<!--   choice_validation <- choicelist %>% -->
<!--     unique() %>% -->
<!--     data.table::transpose() %>% -->
<!--     stats::setNames(.[1, ]) %>% -->
<!--     dplyr::slice(-1) %>% -->
<!--     dplyr::mutate_all(~ stringr::str_split(., ";\n")) -->

<!--   nrow_validation <- lapply(choice_validation, function(x) length(x[[1]])) %>% -->
<!--     unlist() %>% -->
<!--     max() -->

<!--   data.val <- data.frame(matrix(NA, nrow = nrow_validation, ncol = 0)) -->

<!--   for (c in colnames(choice_validation)) { -->
<!--     data.val <- data.val %>% -->
<!--       dplyr::mutate(!!rlang::sym(c) := c(unlist(choice_validation[[c]]), rep(NA, nrow_validation - length(choice_validation[[c]][[1]])))) -->
<!--   } -->

<!--   return(data.val) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-create_validation_list} -->
<!-- # Assume choices_df and tool_df are sample dataframes that fit the expected structure. -->
<!-- #validation_list <- create_validation_list(choices, tool) -->
<!-- ``` -->

<!-- ```{r tests-create_validation_list} -->
<!-- test_that("create_validation_list works", { -->
<!--   expect_true(inherits(create_validation_list, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## create_formatted_choices -->

<!-- ```{r function-create_formatted_choices} -->
<!-- #' Format and filter Choices for 'select_one' Questions -->
<!-- #' -->
<!-- #' This function returns a dataframe containing 'select_one' questions -->
<!-- #' from the `tool` dataframe with their corresponding choices in the `choices` dataframe. -->
<!-- #' -->
<!-- #' @param choices A dataframe containing the choices sheet from the Kobo tool -->
<!-- #'        Expected to have at least the columns `list_name` and `name`. -->
<!-- #' -->
<!-- #' @param tool A dataframe containing the survey sheet from the Kobo tool -->
<!-- #'        Expected to have at least the columns `type` and `name`. -->
<!-- #' -->
<!-- #' @return A dataframe containing 'select_one' questions with their corresponding choices. -->
<!-- #'         The dataframe has columns from both the `tool` and `choices` dataframes. -->
<!-- #' -->
<!-- #' @export -->
<!-- create_formatted_choices <- function(choices, tool) { -->
<!--   list.choices <- choices %>% -->
<!--     dplyr::filter(!is.na(list_name)) %>% -->
<!--     dplyr::group_by(list_name) %>% -->
<!--     dplyr::mutate( -->
<!--       choices = paste(name, collapse = ";\n"), -->
<!--       choices.label = paste(!!rlang::sym(names(choices)[3]), collapse = ";\n") -->
<!--     ) %>% -->
<!--     dplyr::summarise(choices = choices[1], choices.label = choices.label[1]) -->

<!--   select.questions <- tool %>% -->
<!--     dplyr::select(type, name) %>% -->
<!--     dplyr::mutate( -->
<!--       q.type = as.character(lapply(type, function(x) { -->
<!--         return(stringr::str_split(x, " ")[[1]][1]) -->
<!--       })), -->
<!--       list_name = as.character(lapply(type, function(x) { -->
<!--         x.1 <- stringr::str_split(x, " ")[[1]] -->
<!--         if (length(x.1) == 1) { -->
<!--           return(NA) -->
<!--         } else { -->
<!--           return(x.1[2]) -->
<!--         } -->
<!--       })) -->
<!--     ) %>% -->
<!--     dplyr::filter(q.type == "select_one") %>% -->
<!--     dplyr::filter(!is.na(list_name) & list_name != "NA" & list_name != "group" & list_name != "repeat") %>% -->
<!--     dplyr::left_join(list.choices, by = "list_name") %>% -->
<!--     dplyr::filter(!is.na(choices)) -->

<!--   return(select.questions) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-create_formatted_choices} -->
<!-- #formatted_choices <- create_formatted_choices(choices, tool) -->
<!-- ``` -->

<!-- ```{r tests-create_formatted_choices} -->
<!-- test_that("create_formatted_choices works", { -->
<!--   expect_true(inherits(create_formatted_choices, "function"))  -->
<!-- }) -->
<!-- ``` -->


<!-- ## create_col_range -->

<!-- ```{r function-create_col_range} -->
<!-- #' Generate excel range to be used for the data validation formula in excel -->
<!-- #' -->
<!-- #' This function returns an Excel cell range for a given column in a dataframe. -->
<!-- #' The range is formatted for use in Excel functions or formulas and is prefixed -->
<!-- #' with the sheet name 'validation_rules'. -->
<!-- #' -->
<!-- #' @param variable The name of the column/question for which the Excel range is to be generated. -->
<!-- #' @param data.val A dataframe containing the column specified by `variable`. -->
<!-- #' -->
<!-- #' @return A string representing the Excel cell range containing all choices for the column `variable` -->
<!-- #'         in the sheet 'validation_rules'. -->
<!-- #' -->
<!-- #' @export -->
<!-- create_col_range <- function(variable, data.val) { -->
<!--   column.number <- which(colnames(data.val) == variable) -->
<!--   all <- expand.grid(LETTERS, LETTERS) -->
<!--   all <- all[order(all$Var1, all$Var2), ] -->
<!--   alphabet <- c(LETTERS, do.call("paste0", all)) -->
<!--   col.excel <- alphabet[column.number] -->
<!--   nrow <- nrow(data.val %>% dplyr::filter(!is.na(!!rlang::sym(variable)))) -->
<!--   range.vect <- c("$", col.excel, "$2:$", col.excel, "$", (nrow + 1)) -->
<!--   range <- paste(range.vect, sep = "", collapse = "") -->
<!--   value.sheet <- paste("'validation_rules'!") -->
<!--   value <- paste(value.sheet, range, sep = "", collapse = "") -->
<!--   return(value) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-create_col_range} -->
<!--  # Assume df is a sample dataframe with a column named 'consent'. -->
<!-- #range_string <- create_col_range('consent', df) -->
<!-- ``` -->

<!-- ```{r tests-create_col_range} -->
<!-- test_that("create_col_range works", { -->
<!--   expect_true(inherits(create_col_range, "function"))  -->
<!-- }) -->
<!-- ``` -->


<!-- ## coerce_to_character -->

<!-- ```{r function-coerce_to_character} -->
<!-- #' Coerce numeric values to character, without scientific noting and NA are kept as NA. -->
<!-- #' -->
<!-- #' @param x a value to convert -->
<!-- #' -->
<!-- #' @return x as character -->
<!-- #' @export -->

<!-- coerce_to_character <- function(x) { -->
<!--   format(x, scientific = F, justify = "none", trim = T) %>% -->
<!--     dplyr::na_if("NA") -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-coerce_to_character} -->
<!-- coerce_to_character(c("a", NA)) -->
<!-- coerce_to_character(c(1, 10000000, NA)) -->
<!-- ``` -->

<!-- ```{r tests-coerce_to_character} -->
<!-- test_that("coerce_to_character works", { -->
<!--   expect_true(inherits(coerce_to_character, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## detect_uuid -->

<!-- ```{r function-detect_uuid} -->
<!-- #' Helper to look to guess uuid name -->
<!-- #' -->
<!-- #' @param dataset dataset to look from -->
<!-- #' @param name_to_search pattern to search, default is "uuid" -->
<!-- #' -->
<!-- #' @return text vector with the name to search. -->
<!-- #'  If there is 0 or 2 or more possible ansers, it will -->
<!-- #' give an error. -->
<!-- #'  -->
<!-- #' @keywords internal -->
<!-- #'  -->
<!-- #' @export -->


<!-- detect_uuid <- function(dataset, name_to_search = "uuid") { -->
<!--   name_to_return <- grep(name_to_search, names(dataset), value = T) -->

<!--   if(length(name_to_return) != 1) { -->
<!--     msg <- glue::glue("Cannot identify a column with the pattern \"",  -->
<!--                       name_to_search,  -->
<!--                       "\". There are ", -->
<!--                       length(name_to_return),  -->
<!--                       " results from grep") -->
<!--     stop(msg) -->
<!--   } -->

<!--   return(name_to_return) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-detect_uuid} -->
<!-- test1_df <- data.frame(uuid = letters, -->
<!--                           x = runif(26), -->
<!--                           hello = LETTERS) -->
<!-- detect_uuid(test1_df) -->
<!-- ``` -->

<!-- ```{r tests-detect_uuid} -->
<!-- test_that("detect_uuid works", { -->
<!--   expect_true(inherits(detect_uuid, "function"))  -->
<!-- }) -->
<!-- ``` -->


<!-- ## knit_big_table -->

<!-- ```{r function-knit_big_table} -->
<!-- #' Format table for quarto html output -->
<!-- #' -->
<!-- #' @param table_to_print A data frame to print -->
<!-- #' @param .height Height in the html output -->
<!-- #' -->
<!-- #' @return Table with some features for quarto html output -->
<!-- #'  -->
<!-- #' @keywords internal -->
<!-- #' @export -->

<!-- knit_big_table <- function(table_to_print, .height = "500px") { -->
<!--   table_to_print |> -->
<!--     knitr::kable() |> -->
<!--     kableExtra::kable_paper() |> -->
<!--     kableExtra::scroll_box(height = .height) -->
<!-- } -->

<!-- ``` -->

<!-- ```{r example-knit_big_table} -->
<!-- #knit_big_table(table_to_print) -->
<!-- ``` -->

<!-- ```{r tests-knit_big_table} -->
<!-- test_that("knit_big_table works", { -->
<!--   expect_true(inherits(knit_big_table, "function"))  -->
<!-- }) -->
<!-- ``` -->

<!-- ## print_log -->

<!-- ```{r function-print_log} -->
<!-- #' Help to print log or message for the template -->
<!-- #' -->
<!-- #' @param log_to_print A data frame to print -->
<!-- #' @param message A message to print if the data frame is empty -->
<!-- #' -->
<!-- #' @return The data frame to print or an alternative message  -->
<!-- #' if the dataframe is empty -->
<!-- #'  -->
<!-- #' @keywords internal -->
<!-- #' @export -->

<!-- print_log <- function(log_to_print, message) { -->
<!--   if(nrow(log_to_print) == 0) { -->
<!--     cat(message) -->
<!--   } else { -->
<!--     log_to_print |> knit_big_table() -->
<!--   } -->
<!-- } -->
<!-- ``` -->

<!-- ```{r example-print_log} -->
<!-- #print_log(log_to_print, "No values flagged") -->
<!-- ``` -->

<!-- ```{r tests-print_log} -->
<!-- test_that("print_log works", { -->
<!--   expect_true(inherits(print_log, "function"))  -->
<!-- }) -->
<!-- ``` -->


<!-- ## Archive files in RIDL -->


<!-- ```{r function-add_ridl} -->
<!-- #' Archive all crunching files in RIDL -->
<!-- #' -->
<!-- #' RIDL is UNHCR instance of a CKAN server and is accessible for UNHCR staff at -->
<!-- #' https://ridl.unhcr.org . It is designed to keep track and -->
<!-- #' document dataset within an organisation. -->
<!-- #' -->
<!-- #' You conveniently archive there your generated cleaning report and save -->
<!-- #' the work you did on a notebook: As you have been working on the data, you want -->
<!-- #' to keep track of it and save your work in a place where it can be useful for -->
<!-- #' other people and available for peer review and quality assessment. -->
<!-- #' -->
<!-- #' -->
<!-- #' The function saves within the  the RIDL container you used to get the data -->
<!-- #'  from the following resources: -->
<!-- #'   * the source notebook -->
<!-- #'   * the cleaning log -->
<!-- #'   * the cleaned data -->
<!-- #' -->
<!-- #' The function behavior is the following - -->
<!-- #'   1. Get metadata from the RIDL dataset -->
<!-- #'   2. check if the resources to be uploaded is already shared based on the name -->
<!-- #'   3. if already there update, if not create -->
<!-- #' -->
<!-- #'  The function relies on   # install.packages("pak") -->
<!-- #'                           # pak::pkg_install("edouard-legoupil/riddle") -->
<!-- #' -->
<!-- #' @param ridl ridl container where the resources should be added -->
<!-- #' @param datafolder folder where the data used by the notebook are stored -->
<!-- #' @param cleaned_data names of the file with the cleaned data -->
<!-- #' @param cleaning_log names of the file with the cleaning_log  -->
<!-- #' @param namethisfile all files are archived based on the name of notebook you created. -->
<!-- #'     The function automatically get the name of the notebook where it is run from, -->
<!-- #'     using -->
<!-- #'      basename(rstudioapi::getSourceEditorContext()$path ) -->
<!-- #' -->
<!-- #' -->
<!-- #' @importFrom riddle dataset_show resource_metadata resource_create resource_update -->
<!-- #' -->
<!-- #' @return nothing all analysis files are added as a resources -->
<!-- #'  -->
<!-- #' @keywords internal  -->
<!-- #' -->
<!-- #' @export -->

<!-- # prefixer::import_from(fun = add_ridl) -->

<!-- add_ridl <- function(ridl, -->
<!--                       datafolder, -->
<!--                       cleaned_data, -->
<!--                       cleaning_log, -->
<!--                       namethisfile){ -->

<!--  ### name of the file... -->
<!-- # retrieving path from getSourceEditorContext() -->
<!-- # using $ operator -->
<!-- ## Enter below the name you used to save this file - without extension -->
<!-- #    namethisfile <- rstudioapi::getSourceEditorContext()$path -->

<!-- ### Remove file name extension -->
<!-- name <-  substr(namethisfile,1, nchar(namethisfile) -4) -->
<!-- # -->
<!-- #    ## Now just the name of the file -->
<!-- #    name1 <-   basename(rstudioapi::getSourceEditorContext()$path ) -->
<!-- #    ## Remove file name extension -->
<!-- #   name <-  substr(name1,1, nchar(name1) -4) -->
<!-- # -->
<!-- #     ### Time to archive your work once done!! -->

<!-- time <- format(Sys.Date(),  '%d%b%y') -->

<!-- # ### Uncomment and Run this only once you have knitted your file in order to quickly upload this to RIDL - -->
<!-- # install.packages("pak") -->
<!-- # pak::pkg_install("edouard-legoupil/riddle") -->

<!-- # First let's get the dataset metadata -->
<!-- p <- riddle::dataset_show(ridl) -->
<!-- list_of_resources <- p[["resources"]][[1]] -->
<!-- #names(list_of_resources) -->
<!-- #   "description" -->
<!-- # "file_type"        questionnaire microdata report script -->
<!-- # "format" -->
<!-- # "id"    "name" -->
<!-- # "type"                "url" -->
<!-- # "visibility" -->
<!-- # "identifiability" -->
<!-- # "version" -->
<!-- # "script_dependencies" -->
<!-- # "script_instructions" -->
<!-- #  "script_software" -->
<!-- # "source_code_repo" -->

<!-- ### 1.  Publish the cleaned_data ####### -->
<!-- namecleaned_data = paste0("cleaned_data" ) -->
<!-- ### Check if the name is already in the resources -->
<!-- if(namecleaned_data %in% list_of_resources$name) { -->
<!--   ## get the resource id -->
<!--   resourceid <- list_of_resources |> -->
<!--     dplyr::filter ( name == namecleaned_data) |> -->
<!--     dplyr::pull(id) -->
<!--   ## get the new resource version -->
<!--   curversion <- list_of_resources |> -->
<!--     dplyr::filter ( name == namecleaned_data) |> -->
<!--     dplyr::pull(version) -->

<!--   ##  Build resource metadata -->
<!--   metadatacleaned_data <- riddle::resource_metadata( -->
<!--     type = "data", -->
<!--     url = paste0("cleaned_data.xlsx"), -->
<!--     name = namecleaned_data, -->
<!--     description = paste0("Cleaned version of the data in relation with standard cleaning log. Built using cleaningtools "), -->
<!--     format = ".xlsx", -->
<!--     version = (curversion + 1), -->
<!--     date_range_end = list_of_resources |> -->
<!--       dplyr::filter ( file_type == "microdata") |> -->
<!--       dplyr::select(date_range_end) |> -->
<!--       dplyr::distinct() |> -->
<!--       dplyr::pull(), -->
<!--     date_range_start =  list_of_resources |> -->
<!--       dplyr::filter ( file_type == "microdata") |> -->
<!--       dplyr::select(date_range_start) |> -->
<!--       dplyr::distinct() |> -->
<!--       dplyr::pull(), -->
<!--     identifiability =  "personally_identifiable",  -->
<!--     visibility =  "restricted", -->
<!--     process_status = "cleaned", -->
<!--     # file_type = "other", -->
<!--     file_type = "microdata", -->
<!--     script_dependencies= "cleaningtools", -->
<!--     script_instructions= "This excel file contains cleaned version of the data in line with the cleaning log ", -->
<!--     script_software= "R", -->
<!--     source_code_repo= "https://edouard-legoupil.github.io/cleaningtools", -->
<!--     ## Revise here based on the name from your crunching report -->
<!--     upload =  httr::upload_file(here::here(datafolder, cleanned_data)) -->
<!--   ) -->
<!--   riddle::resource_update(id = resourceid, -->
<!--                           res_metadata = metadatacleaned_data) -->
<!-- } else { -->

<!--   metadatacleaned_data <- riddle::resource_metadata( -->
<!--               type = "data", -->
<!--               url = paste0("cleaned_data.xlsx"), -->
<!--               name = namecleaned_data, -->
<!--               description = paste0("Cleaned version of the data in relation with standard cleaning log. Built using cleaningtools"), -->
<!--               format = ".xlsx", -->
<!--               version =   1 , -->
<!--               date_range_end = list_of_resources |> -->
<!--                                   dplyr::filter ( file_type == "microdata") |> -->
<!--                                   dplyr::select(date_range_end) |> -->
<!--                                   dplyr::distinct() |> -->
<!--                                   dplyr::pull(), -->
<!--               date_range_start =  list_of_resources |> -->
<!--                                     dplyr::filter ( file_type == "microdata") |> -->
<!--                                     dplyr::select(date_range_start) |> -->
<!--                                     dplyr::distinct() |> -->
<!--                                     dplyr::pull(), -->
<!--               identifiability =  "personally_identifiable",  -->
<!--               visibility =  "restricted", -->
<!--               process_status = "cleaned", -->
<!--               #  file_type = "other", -->
<!--               file_type = "microdata", -->
<!--               script_dependencies= "cleaningtools", -->
<!--               script_instructions= "This excel file contains all specific metedata -->
<!--                        to relabel the original data, to group variable for automatic data -->
<!--                         exploration and to create calculated variables ", -->
<!--               script_software= "R", -->
<!--               source_code_repo= "https://edouard-legoupil.github.io/cleaningtools", -->
<!--               ## Revise here based on the name from your crunching report -->
<!--               upload =  httr::upload_file(here::here(datafolder,cleanned_data)) -->
<!--             ) -->
<!--   riddle::resource_create(package_id = p$id, -->
<!--                           res_metadata = metadatacleaned_data) -->
<!-- } -->


<!-- ### 2.  Now publish the current notebook ####### -->
<!-- namenotebook = paste0("notebook_cleaning") -->
<!-- ### Check if the name is already in the resources -->
<!-- if(namenotebook %in% list_of_resources$name) { -->
<!--   ## get the resource id -->
<!--   resourceid <- list_of_resources |> -->
<!--     dplyr::filter ( name == namenotebook) |> -->
<!--     dplyr::pull(id) -->
<!--   ## get the new resource version -->
<!--   curversion <- list_of_resources |> -->
<!--     dplyr::filter ( name == namenotebook) |> -->
<!--     dplyr::pull(version) -->
<!--   metadatanamenotebook <- riddle::resource_metadata(type = "script", -->
<!--                                                       url = paste0("notebook_cleaning.Rmd"), -->
<!--                                                       name = namenotebook, -->
<!--                                                       description = paste0("Notebook for cleaning report. Built using cleanningtools "), -->
<!--                                                       format = "rmd", -->
<!--                                                       version = (curversion + 1), -->
<!--                                                       visibility =  "public", -->
<!--                                                       #             file_type = "other", -->
<!--                                                       file_type = "script", -->
<!--                                                       script_dependencies= "cleaningtools", -->
<!--                                                       script_instructions= "Use the raw data data and the cleaning log to rebuild the cleaned data ", -->
<!--                                                       script_software= "R", -->
<!--                                                       source_code_repo= "https://edouard-legoupil.github.io/cleaningtools", -->
<!--                                                       # Revise here based on the name from your crunching report -->
<!--                                                       upload = httr::upload_file(here::here(namethisfile)) -->
<!--   ) -->

<!--   riddle::resource_update(id = resourceid, -->
<!--                           res_metadata =  metadatanamenotebook) -->
<!-- } else { -->
<!--   metadatanamenotebook <- riddle::resource_metadata(type = "script", -->
<!--                                                       url = paste0("notebook_cleaning.Rmd"), -->
<!--                                                       name = namenotebook, -->
<!--                                                       description = paste0("Notebook for cleaning report. Built using cleanningtools  "), -->
<!--                                                       format = "Rmd", -->
<!--                                                       visibility =  "public", -->
<!--                                                       #            file_type = "other", -->
<!--                                                       file_type = "script", -->
<!--                                                       script_dependencies= "cleaningtools", -->
<!--                                                       script_instructions= "Use the data and the analysis -->
<!--                                            plan documented in the report parameters and -->
<!--                                            available within this RIDL dataset ", -->
<!--                                                       script_software= "R", -->
<!--                                                       source_code_repo= "https://edouard-legoupil.github.io/cleaningtools", -->
<!--                                                       ## Revise here based on the name from your crunching report -->
<!--                                                       upload = httr::upload_file(here::here(namethisfile)) -->
<!--   ) -->
<!--   riddle::resource_create(package_id = p$id, -->
<!--                           res_metadata = metadatanamenotebook) -->
<!-- } -->

<!-- ## 3.  and now the cleanning log -->
<!-- namelog = paste0("Cleaning_log") -->
<!-- ### Check if the name is already in the resources -->
<!-- if(namelog %in% list_of_resources$name) { -->
<!--   ## get the resource id -->
<!--   resourceid <- list_of_resources |> -->
<!--     dplyr::filter ( name == namelog) |> -->
<!--     dplyr::pull(id) -->
<!--   ## get the new resource version -->
<!--   curversion <- list_of_resources |> -->
<!--     dplyr::filter ( name == namelog) |> -->
<!--     dplyr::pull(version) -->
<!--   metadatalog <- riddle::resource_metadata( -->
<!--     type = "attachment", -->
<!--     url = paste0("cleaning_log.xlsx"), -->
<!--     name = namelog, -->
<!--     description = paste0("Systematic cleaning log. Built using cleaningtools "), -->
<!--     format = ".xlsx", -->
<!--     version = (curversion + 1), -->
<!--     identifiability =  "personally_identifiable",  -->
<!--     visibility =  "restricted", -->
<!--     file_type = "other", -->
<!--     script_dependencies= "cleaningtools", -->
<!--     script_instructions= "This excel file contains cleaned version of the data in line with the cleaning log ", -->
<!--     script_software= "R", -->
<!--     source_code_repo= "https://edouard-legoupil.github.io/cleaningtools", -->
<!--     ## Revise here based on the name from your crunching report -->
<!--     upload =  httr::upload_file(here::here(datafolder, cleaning_log)) -->
<!--   ) -->

<!--   riddle::resource_update(id = resourceid, -->
<!--                           res_metadata = metadatalog) -->
<!-- } else { -->
<!--   metadatalog <- riddle::resource_metadata( -->
<!--     type = "attachment", -->
<!--     url = paste0("cleaning_log.xlsx"), -->
<!--     name = namelog, -->
<!--     description = paste0("Systematic cleaning log. Built using cleaningtools "), -->
<!--     format = ".xlsx", -->
<!--     version =  1, -->
<!--     identifiability =  "personally_identifiable",  -->
<!--     visibility =  "restricted", -->
<!--     file_type = "other", -->
<!--     script_dependencies= "cleaningtools", -->
<!--     script_instructions= "This excel file contains cleaned version of the data in line with the cleaning log ", -->
<!--     script_software= "R", -->
<!--     source_code_repo= "https://edouard-legoupil.github.io/cleaningtools", -->
<!--     ## Revise here based on the name from your crunching report -->
<!--     upload =  httr::upload_file(here::here(datafolder, cleaning_log)) -->
<!--   )  -->
<!--   riddle::resource_create(package_id = p$id, -->
<!--                           res_metadata = metadatalog) -->
<!-- } -->


<!-- ## Once all of it done, let's the user know about it... -->
<!-- return( cat(paste0("Congrat! The Cleaned data, the cleaning log and the Notebook have been published on RIDL"))) -->
<!-- } -->




<!-- ``` -->

<!-- ```{r example-add_ridl} -->

<!-- ### Example used for each template  -->
<!-- ## Time to archive your work once done!! -->
<!-- # namethisfile = basename(rstudioapi::getSourceEditorContext()$path )   -->
<!-- # if( params$publish == "yes"){ -->
<!-- #   add_ridl(ridl = params$ridl, -->
<!-- #             datafolder = params$datafolder, -->
<!-- #             form = params$form, -->
<!-- #             namethisfile =  namethisfile ) } -->


<!-- ``` -->

<!-- ```{r tests-add_ridl} -->


<!-- # Unit test for add_ridl() using testthat -->
<!-- #  -->
<!-- # context("add_ridl()") -->
<!-- #  -->
<!-- # # Create mock objects to use in the test -->
<!-- # ridl <- "testRidl" -->
<!-- # datafolder <- "data" -->
<!-- # form <- "form.xlsx" -->
<!-- # namethisfile <- "testFile" -->
<!-- # visibility <- "public" -->
<!-- # stage <- "explo_initial" -->
<!-- #  -->
<!-- # # Create test for function -->
<!-- # test_that("add_ridl() creates the right resources", { -->
<!-- #   expect_true(add_ridl(ridl, datafolder, form, namethisfile, visibility, stage)) -->
<!-- # }) -->

<!-- # test_that("add_ridl works", {   expect_true(inherits(add_ridl, "function")) }) -->
<!-- ``` -->




<!-- ```{r development-inflate, eval=FALSE} -->
<!-- # Run but keep eval=FALSE to avoid infinite loop -->
<!-- # Execute in the console directly -->
<!-- fusen::inflate(flat_file = "dev/function_documentation.Rmd", vignette_name = "function_documentation") -->
<!-- ``` -->

